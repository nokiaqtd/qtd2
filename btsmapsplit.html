<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <title>BTS Azimuth Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
 <!-- Dexie for IndexedDB -->
  <script src="https://cdn.jsdelivr.net/npm/dexie@3/dist/dexie.min.js"></script>
  <!-- Turf & RBush for spatial -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/rbush@3/rbush.min.js"></script>
  <script type="module">
  import geojsonRbush from 'https://cdn.skypack.dev/geojson-rbush';
    window.geojsonRbush = geojsonRbush;
  </script>


  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }

    /* ---------- NEW control panel styles (replace existing .control-panel and #toggle-panel) ---------- */
    :root{
      --panel-bg: rgba(255,255,255,0.95);
      --panel-accent: #0b76ff;
      --panel-radius: 12px;
      --gap: 8px;
      --touch: 44px;
      --shadow: 0 6px 24px rgba(0,0,0,0.12);
      --glass: rgba(255,255,255,0.6);
    }

    /* base */
    .control-panel{
      position: absolute;
      top: 12px;
      right: 12px;
      width: 320px;
      max-width: calc(100% - 24px);
      background: var(--panel-bg);
      border-radius: var(--panel-radius);
      box-shadow: var(--shadow);
      z-index: 1100;
      font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      transition: transform .28s ease, opacity .2s ease;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
      padding: 8px;
      box-sizing: border-box;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }

    /* collapsed state */
    .control-panel.collapsed{
      transform: translateY(-12px) scale(.98);
      opacity: 0;
      pointer-events: none;
    }

    /* header */
    .control-panel .panel-head{
      display:flex;
      align-items:center;
      gap:8px;
      padding:4px 6px;
    }
    .control-panel .panel-title{
      font-weight:600;
      font-size:14px;
      flex:1;
    }
    .control-panel .panel-actions button{
      height:28px;
      min-width:28px;
      border-radius:6px;
      border: none;
      background: transparent;
      cursor:pointer;
      color: #333;
      padding: 4px;
    }

    /* compact form layout */
    .control-panel .panel-body{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      padding:6px;
    }
    .control-panel label{ font-size:13px; display:block; width:100%; }
    .control-panel .row{ display:flex; gap:8px; align-items:center; width:100%; }
    .control-panel select, .control-panel input[type="text"], .control-panel input[type="range"]{
      width:100%;
      padding:6px 8px;
      border-radius:6px;
      border:1px solid #e6e6e6;
      font-size:13px;
      box-sizing:border-box;
    }

    /* footer */
    .control-panel .panel-foot{
      display:flex;
      gap:8px;
      padding:6px;
      align-items:center;
      justify-content:space-between;
    }

    /* floating FAB toggle (show when panel hidden or on mobile) */
    #toggle-panel{
      position: absolute;
      right: 16px;
      top: 16px;
      z-index: 1200;
      width: 44px;
      height: 44px;
      border-radius: 999px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--panel-accent);
      color: #fff;
      border: none;
      box-shadow: 0 6px 18px rgba(11,118,255,0.24);
      cursor: pointer;
      font-weight:700;
      font-size:20px;
      padding:0;
    }

    /* responsive: mobile bottom-sheet */
    /* @media (max-width:640px){
      .control-panel{
        left: 12px;
        right: 12px;
        width: calc(100% - 24px);
        bottom: 12px;
        top: auto;
        flex-direction: column;
        padding: 10px;
      }
      #toggle-panel{ right: 12px; top: auto; bottom: 80px; }
    } */


    .bts-label { white-space: nowrap; font-weight: bold; font-size: 13px; color: white;
      text-shadow: -1px -1px 0 black,1px -1px 0 black,-1px 1px 0 black,1px 1px 0 black;
      background-color: transparent; padding: 2px 4px; pointer-events: auto; }
    .context-menu, .popup-list {
      position: absolute; background: white; padding: 6px;
      border: 1px solid #ccc; border-radius: 4px;
      z-index: 1100; display: none;
    }
    .context-menu div, .popup-list div { padding: 4px; cursor: pointer; }
    .context-menu div:hover, .popup-list div:hover { background: #eee; }
    #bottomBar {
      position: absolute; bottom: 10px; left: 10px;
      display: flex; align-items: center; z-index: 1200;
    }
    #coordDisplay {
      background: rgba(0,0,0,0.7); color: #fff;
      padding: 4px 8px; border-radius: 4px;
      font-family: sans-serif;
    }

    .info-popup {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: white; padding: 20px; border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      z-index: 1200; display: none; width: 300px;
    }
    .info-popup .close-btn { position: absolute; top: 5px; right: 8px; cursor: pointer; font-weight: bold; }


    #searchResults ul {
      margin: 0; padding: 4px; list-style: none;
    }
    #searchResults li { padding: 2px 4px; cursor: pointer; }
    #searchResults li:hover { background: #eef; }
    #searchResults .pagination { text-align: center; padding: 4px; }
    #searchResults .pagination span {
      margin: 0 4px;
      cursor: pointer;
      color: blue;            /* hyperlink color */
      text-decoration: underline;
    }
    #searchResults .pagination .active { font-weight: bold; text-decoration: underline; }

    #searchResults .result-row.hovered,
    #searchResults .result-row.pinned {
      background: color-mix(in srgb, var(--accent) 16%, white 84%);
      border: 1px solid rgba(11,118,255,0.18);
      box-shadow: 0 10px 26px rgba(11,118,255,0.12);
    }


    #perfBadge {
      position: absolute;
      top: 8px; right: 8px;
      font: 12px sans-serif;
      padding: 2px 4px;
      background: rgba(0,0,0,0.5);
      color: white;
      z-index: 1300;
      /* black outline via multiple shadows */
      text-shadow:
      -1px -1px 0 #000, 1px -1px 0 #000,
      -1px 1px 0 #000, 1px 1px 0 #000;
      border-radius: 4px;
    }  
    
    
      
    .leaflet-container {
    background-color: hsl(219,100%,50%);
    background-size:    200px 100px,200px 100px;
    background-position:0 0,100px 50px;
    background-repeat:  repeat,repeat;
    /* two identical data-URIs with the full path data */
    background-image:
      url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='200' height='100' viewBox='0 0 200 100'><rect width='200' height='100' fill='transparent'/><svg x='55' y='30' width='90' height='40' viewBox='0 0 55 13' fill='none' xmlns='http://www.w3.org/2000/svg'><g clip-path='url(%23clip0)'><path d='M38.0192 0.395349V12.6046H39.842V0.395349H38.0192ZM18.5454 0.186787C14.9944 0.186771 12.2392 2.78308 12.2392 6.5C12.2392 10.3843 14.9944 12.8133 18.5454 12.8132C22.0964 12.8132 24.8572 10.3843 24.8516 6.5C24.8464 2.97836 22.0964 0.186803 18.5454 0.186787ZM23.0321 6.5C23.0321 9.25164 21.0233 11.0752 18.5454 11.0752C16.0674 11.0752 14.0587 9.25164 14.0587 6.5C14.0587 3.79827 16.0674 1.92486 18.5454 1.92486C21.0233 1.92486 23.0321 3.79827 23.0321 6.5ZM0 1.10175e-06V12.6046H1.86027V4.27476L11.5273 13V10.3867L0 1.10175e-06ZM26.2225 6.5L32.9874 12.6047H35.6999L28.9248 6.5L35.6999 0.395343H32.9874L26.2225 6.5ZM55 12.6046H52.9948L51.5285 9.90093H44.8871L43.4206 12.6046H41.4153L43.8437 8.09822H50.5748L47.2185 1.83556L48.2078 0L55 12.6046Z' fill='white'/></g><defs><clipPath id='clip0'><rect width='55' height='13' fill='white'/></clipPath></defs></svg></svg>"),
      url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='200' height='100' viewBox='0 0 200 100'><rect width='200' height='100' fill='transparent'/><svg x='55' y='30' width='90' height='40' viewBox='0 0 55 13' fill='none' xmlns='http://www.w3.org/2000/svg'><g clip-path='url(%23clip0)'><path d='M38.0192 0.395349V12.6046H39.842V0.395349H38.0192ZM18.5454 0.186787C14.9944 0.186771 12.2392 2.78308 12.2392 6.5C12.2392 10.3843 14.9944 12.8133 18.5454 12.8132C22.0964 12.8132 24.8572 10.3843 24.8516 6.5C24.8464 2.97836 22.0964 0.186803 18.5454 0.186787ZM23.0321 6.5C23.0321 9.25164 21.0233 11.0752 18.5454 11.0752C16.0674 11.0752 14.0587 9.25164 14.0587 6.5C14.0587 3.79827 16.0674 1.92486 18.5454 1.92486C21.0233 1.92486 23.0321 3.79827 23.0321 6.5ZM0 1.10175e-06V12.6046H1.86027V4.27476L11.5273 13V10.3867L0 1.10175e-06ZM26.2225 6.5L32.9874 12.6047H35.6999L28.9248 6.5L35.6999 0.395343H32.9874L26.2225 6.5ZM55 12.6046H52.9948L51.5285 9.90093H44.8871L43.4206 12.6046H41.4153L43.8437 8.09822H50.5748L47.2185 1.83556L48.2078 0L55 12.6046Z' fill='white'/></g><defs><clipPath id='clip0'><rect width='55' height='13' fill='white'/></clipPath></defs></svg></svg>");
    }
      
    
    #loadingLabel {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 10px 20px;
    border-radius: 6px;
    font-family: sans-serif;
    font-size: 16px;
    z-index: 2000;
    display: none;
    }

    @keyframes blink {
    0%,49%   { opacity: 1; }
    50%,100% { opacity: 0; }
    }
    .blinking {
    display: inline-block;
    animation: blink 1s step-start infinite; /* MDN: CSS animation https://developer.mozilla.org/docs/Web/CSS/animation */
    }
    
    /* remove the default divIcon white box */
    .no-bg {
    background: transparent !important;      /* MDN: background https://developer.mozilla.org/docs/Web/CSS/background */
    border: none !important;                /* MDN: border https://developer.mozilla.org/docs/Web/CSS/border */
    }

    :root { --accent: hsl(219,100%,50%); --accent-strong: color-mix(in srgb, var(--accent) 85%, black 15%); }

    /* modern buttons/inputs/combobox */
    .control-panel button,
    .control-panel input[type="button"],
    .control-panel input[type="submit"],
    .control-panel select,
    .control-panel input[type="text"],
    .control-panel input[type="range"] {
      border: 0;
      background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(250,250,250,0.98));
      border-radius: 8px;
      padding: 8px 10px;
      box-shadow: 0 2px 8px rgba(16,24,40,0.06);
      transition: box-shadow .16s ease, transform .12s ease, border-color .12s ease;
      outline: none;
      font-size: 13px;
    }

    /* subtle lift on hover */
    .control-panel button:hover,
    .control-panel select:hover,
    .control-panel input[type="text"]:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(16,24,40,0.12);
      border-color: rgba(0,0,0,0.06);
    }

    /* accent focus / hover states */
    .control-panel button:hover,
    .control-panel button:focus,
    .control-panel select:focus,
    .control-panel input[type="text"]:focus {
      box-shadow: 0 6px 20px rgba(11,118,255,0.14);
      border: 1px solid rgba(11,118,255,0.22);
      caret-color: var(--accent);
    }

    /* small icon buttons */
    .control-panel .panel-actions button {
      background: transparent;
      color: rgba(20,20,20,0.84);
    }
    .control-panel .panel-actions button:hover { color: var(--accent); transform:none; }

    /* select appearance */
    .control-panel select {
      -webkit-appearance: none;
      appearance: none;
      background-image: linear-gradient(45deg, transparent 50%, rgba(0,0,0,0.6) 50%),
                        linear-gradient(135deg, rgba(0,0,0,0.6) 50%, transparent 50%);
      background-position: calc(100% - 18px) calc(1em + 2px), calc(100% - 13px) calc(1em + 2px);
      background-size: 6px 6px, 6px 6px;
      background-repeat: no-repeat;
      padding-right: 34px;
    }

    /* button primary accent */
    .control-panel button#searchBtn,
    .control-panel button#gotoBtn{
      background: linear-gradient(180deg, var(--accent), var(--accent-strong));
      color: #fff;
      font-weight:600;
      box-shadow: 0 8px 22px rgba(11,118,255,0.18);
    }

    /* make Clear All match Clear Points (neutral/secondary) */
    .control-panel button#clearAllBtn,
    .control-panel button#clearPointsBtn {
      background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(250,250,250,0.98));
      color: #111;
      font-weight: 600;
      border: 1px solid rgba(0,0,0,0.06);
      box-shadow: 0 2px 8px rgba(16,24,40,0.06);
      transition: box-shadow .18s ease, filter .12s ease, background-color .12s ease;
    }

    .control-panel button#clearAllBtn:hover,
    .control-panel button#clearPointsBtn:hover {
      filter: brightness(1.03);
      box-shadow: 0 8px 24px rgba(16,24,40,0.08), 0 0 0 4px rgba(11,118,255,0.04);
    }

    .control-panel button#searchBtn:hover,
    .control-panel button#gotoBtn:hover,
    .control-panel button#clearAllBtn:hover {
      transform: translateY(-3px);
      box-shadow: 0 12px 30px rgba(11,118,255,0.22);
    }

    /* ---------- search results styling & layout ---------- */
    #searchResults {
      position: absolute;
      right: 12px;
      top: 88px;                 /* fallback; overridden by JS positioning */
      width: 340px;
      max-height: 80vh;
      overflow: hidden;          /* JS will toggle overflow-y when needed */
      background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(249,249,250,0.98));
      border-radius: 12px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.12);
      padding: 8px;
      z-index: 1225;
      transition: opacity .14s ease;
      display: none;             /* show via existing logic */
      box-sizing: border-box;
    }

    #searchResults .result-row{
      display:flex;
      gap:12px;
      align-items:center;
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      transition: background .12s ease, box-shadow .12s ease;
      user-select:none;
      border: 1px solid transparent;
      margin-bottom:8px;
      box-sizing: border-box;
    }

    /* left container holds id + name and truncates long name */
    #searchResults .result-row .left {
      display:flex;
      flex-direction:column;
      min-width: 0;       /* allow ellipsis to work inside flex */
      overflow: hidden;
      gap: 2px;
    }
    #searchResults .result-row .siteid {
      font-weight:600;
      font-size:13px;
      color:#0f1724;
      white-space:nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #searchResults .result-row .sitename {
      font-size:12px;
      color:#5b6470;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;   /* truncates with "..." when too long */
    }

    /* meta (distance / extra) pinned to right */
    #searchResults .result-row .meta {
      margin-left: auto;
      white-space: nowrap;
      font-size:12px;
      color:#5b6470;
    }

    /* hover/pinned styling (no translate) */
    #searchResults .result-row:not(.pinned):hover {
      background: color-mix(in srgb, var(--accent) 8%, white 92%);
      box-shadow: 0 10px 20px rgba(11,118,255,0.05);
      border-color: rgba(11,118,255,0.08);
    }
    #searchResults .result-row.pinned {
      background: color-mix(in srgb, var(--accent) 16%, white 84%);
      border: 1px solid rgba(11,118,255,0.18);
      box-shadow: 0 10px 26px rgba(11,118,255,0.12);
    }

    /* title / meta */
    .result-row .title { font-weight:600; font-size:13px; color:#0f1724; }
    .result-row .meta { font-size:12px; color:#5b6470; margin-left:auto; }

    /* responsive placement: mobile / portrait bottom anchored */
    /* @media (max-width:640px) {
      #searchResults {
        left: 12px;
        right: 12px;
        top: auto;
        bottom: 12px;
        width: calc(100% - 24px);
        max-height: 46%;
        padding: 10px;
      }
    } */

    /* ---------- Stabilize hover effects (append to end of style) ---------- */
    /* Ensure buttons keep a fixed border so hover doesn't change layout */
    .control-panel button,
    .control-panel input[type="button"],
    .control-panel input[type="submit"],
    .control-panel select,
    .control-panel input[type="text"],
    .control-panel input[type="range"] {
      border: 1px solid transparent; /* fixed width prevents reflow on hover */
      transition: box-shadow .18s ease, background-color .12s ease, filter .12s ease;
      /* remove transform transitions to avoid movement */
      will-change: box-shadow, filter;
    }

    /* elegant no-shift hover */
    .control-panel button:hover,
    .control-panel select:hover,
    .control-panel input[type="text"]:hover {
      filter: brightness(1.03); /* tiny brighten */
      box-shadow: 0 8px 24px rgba(16,24,40,0.08), 0 0 0 4px rgba(11,118,255,0.06);
      border-color: rgba(11,118,255,0.06);
      transform: none !important;
    }

    /* stronger focus ring but no layout change */
    .control-panel button:focus,
    .control-panel select:focus,
    .control-panel input[type="text"]:focus {
      box-shadow: 0 12px 32px rgba(11,118,255,0.12), 0 0 0 6px rgba(11,118,255,0.08);
      outline: none;
      transform: none !important;
    }

    /* small icon buttons only change color; no movement */
    .control-panel .panel-actions button {
      background: transparent;
      color: rgba(20,20,20,0.84);
      border: 1px solid transparent;
    }
    .control-panel .panel-actions button:hover {
      color: var(--accent);
      box-shadow: none;
      transform: none;
    }

    /* primary action buttons: no translate, stronger glow */
    .control-panel button#searchBtn,
    .control-panel button#gotoBtn,
    .control-panel button#clearAllBtn {
      border: 1px solid transparent;
      transition: box-shadow .18s ease, filter .12s ease, background-color .12s ease;
    }
    .control-panel button#searchBtn:hover,
    .control-panel button#gotoBtn:hover,
    .control-panel button#clearAllBtn:hover {
      filter: brightness(1.04);
      box-shadow: 0 14px 38px rgba(11,118,255,0.20), 0 0 0 6px rgba(11,118,255,0.08);
      transform: none !important;
    }

    /* ensure no child element applies movement */
    .control-panel * { backface-visibility: hidden; -webkit-font-smoothing: antialiased; }

    body,
    #searchResults,
    .bts-label,
    #coordDisplay,
    .popup-list,
    .context-menu {
      font-family: system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    .bts-label {
      font-weight: 600;   /* match semibold used in search result siteId */
      font-size: 13px;    /* already 13px in your CSS — keep for parity */
    }

    .bts-label { line-height: 0.5; /* unitless → relative to font-size */ }
    .bts-label b { display: block; line-height: 0.2; }  
    .bts-label span { display: block; line-height: 0.5; } 

    #searchResults .siteid { font-weight: 600; font-size: 13px; }
    #searchResults .sitename { font-size: 12px; }

  </style>
</head>
<body>
  <div id="map"></div>
  <div id="perfBadge"></div>
  
  <!-- NEW: panel toggle FAB + modern controlPanel -->
  <button id="toggle-panel" aria-expanded="true" aria-controls="controlPanel">☰</button>

  <aside id="controlPanel" class="control-panel" role="region" aria-label="Map controls">
    <div class="panel-head">
      <div class="panel-title">Map Controls</div>
      <div class="panel-actions">
        <!-- kept id for backwards compatibility -->
        <button id="collapseBtn" title="Minimize" aria-label="Minimize">−</button>
      </div>
    </div>

    <div class="panel-body">
      <div class="row" style="width:100%">
        <label style="flex:1">Sector style
          <select id="themeSelect" style="margin-top:6px">
            <option value="1" selected>1: blue red yellow</option>
            <option value="2">2: random</option>
            <option value="3">3: green</option>
            <option value="4">4: invisible</option>
          </select>
        </label>
        <label style="width:120px">Map
          <select id="mapTypeSelect" style="margin-top:6px">
            <option value="m">street</option>
            <option value="y">hybrid</option>
            <option value="s" selected>satellite</option>
          </select>
        </label>
      </div>

      <div class="row">
        <label style="flex:1"><input id="measureToggle" type="checkbox" /> calc distance</label>
        <label style="width:48%"><input id="toggleSectors" type="checkbox" /> show sectors</label>
      </div>

      <div class="row">
        <label style="flex:1"><input id="toggleSiteId" type="checkbox" checked /> show siteid</label>
        <label style="width:48%"><input id="toggleSiteName" type="checkbox" /> show sitename</label>
      </div>

      <div class="row">
        <label style="flex:1"><input id="toggleAlwaysShow" type="checkbox" checked /> always show</label>
        <button id="clearAllBtn" style="min-width:108px">Clear Sites</button>
      </div>

      <div class="row">
        <input id="gotoInput" type="text" placeholder="lon,lat or lat,lon; multi pairs" />
        <div style="display:flex;gap:6px">
          <button id="gotoBtn">Add</button>
          <button id="clearPointsBtn">Clear</button>
        </div>
      </div>

      <div class="row">
        <input id="searchInput" type="text" placeholder="Search siteid or name" />
        <button id="searchBtn">Search</button>
      </div>
    </div>

    <div class="panel-foot">
      <div style="display:flex;gap:8px;align-items:center;">
        <label style="font-size:13px">Zoom <input id="zoomSlider" type="range" min="7" max="20" step="1" value="16" /></label>
        <label style="font-size:13px">Sector Range 
          <!-- <input id="rangeSlider" type="range" min="10" max="2000" step="10" value="100" /> -->
          <select id="rangeSlider" title="Select range">
            <option value="10">10 m</option>
            <option value="25">25 m</option>
            <option value="50">50 m</option>
            <option value="100" selected >100 m</option>
            <option value="250">250 m</option>
            <option value="500" >500 m</option>
            <option value="1000">1 km</option>
            <option value="2000">2 km</option>
            <option value="4000">4 km</option>
          </select>          
          </label>
      </div>
      <div style="display:flex;gap:8px;align-items:center;">
        <label style="font-size:13px">Text <input id="textSizeSlider" type="range" min="8" max="24" step="1" value="13" /></label>        
      </div>
    </div>
  </aside>


  <div id="searchResults">
    <ul></ul>
    <div class="pagination"></div>
  </div>
  <div id="searchPopup" class="popup-list"></div>
  <div id="contextMenu" class="context-menu"></div>
  <div id="infoPopup" class="info-popup">
    <div class="close-btn" id="infoClose">×</div>
    Available on next release
  </div>
  <div id="bottomBar">
    <div id="coordDisplay">Lat: -, Lng: -</div>
  </div>


  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <script>

	/* showNotification - displays "from backend: " + text for 3 seconds */
	console.log('backend ready');


	/* postMessage fallback (use origin check in production) */
	window.addEventListener('message', function(ev) {
	  // IMPORTANT: in production replace '*' below with allowed origin and check ev.origin  	  
    console.log('message received', ev.origin, ev.data);
    
	  var data = ev.data || {};
	  try {
		if (data && data.type === 'search') {
		  //window.showNotification(data.text);
		  window.sitesearch(data.text);
		}
	  } catch (e) { /* ignore malformed messages */ }
	}, false);



  window.sitesearch = async function searchsite2(text) {
      const term = (text || '').trim().toLowerCase();


      try {
        // 1) primary: search active DB
        let matches = await db.sites
          .filter(function(s){
            // defensive: ensure properties exist
            const sid = (s.siteId || '').toString().toLowerCase();
            const sname = (s.sitename || '').toString().toLowerCase();
            return sid.indexOf(term) !== -1 || sname.indexOf(term) !== -1;
          })
          .toArray();

        // 2) if no DB match and background streaming is active (or usingTempMemory),
        //    also check tempMemory (fast, in-memory)
        if ((!matches || matches.length === 0) && (bgRunning || usingTempMemory)) {
          const tempMatches = [];
          tempMemory.forEach(r => {
            const sid = (r.siteId || '').toString().toLowerCase();
            const sname = (r.sitename || '').toString().toLowerCase();
            if (sid.indexOf(term) !== -1 || sname.indexOf(term) !== -1) {
              tempMatches.push(r);
            }
          });
          if (tempMatches.length) {
            matches = tempMatches;
          }
        }

        allMatches = matches || [];

        if (allMatches.length === 0) {
          resultsList.innerHTML    = '<li>No results</li>';
          paginationDiv.innerHTML  = '';
          showSearchResultsAtPanel();
          return 'site not found';
        }

        if (allMatches.length === 1) {
          const site = allMatches[0];
          map.setView([site.lat, site.lon], +zoomSlider.value);
          site.azimuths = (String(site.azRaw || '')).split(';')
                            .map(Number).filter(function(n){return !isNaN(n);});
          currentSites = [site];
          drawAllSectors();

          sr.style.display = 'none';
          //setPanelCollapsed(false);
          return 'site found';
        }

        // multiple matches -> render list (existing behaviour)
        currentPage = 1;
        renderResults();

      } catch (err) {
        console.error('search error', err);
        resultsList.innerHTML = '<li>Error</li>';
        paginationDiv.innerHTML = '';
        showSearchResultsAtPanel();
      }

      return 'ok'

    };





	  const LOCAL_DATA_URL = 'sites.json';
      // ---- GAS environment detector so that index.html can be edited thru local server
      // 1) Detect GAS web-app context
      const isGAS = (
        typeof google === 'object' &&
        google.script &&
        typeof google.script.run === 'object'
      );

  // 2) Define SERVICE_URL appropriately
  // If running *inside* Apps Script this will be templated; otherwise set it to your
  // Apps Script web app exec URL (deployed as "Anyone, even anonymous").
  const SERVICE_URL = isGAS
    // rendered by Apps Script at deploy-time
    ? '<?= serviceUrl ?>'
    // When hosted on GitHub, edit this string to match your Apps Script exec URL:
    // : 'https://script.google.com/macros/s/AKfycbx9o0ovYtav26-k8Vl3RxepPSwpjYbUjgxsf8ClSV00qv43rnZ2efaJFBQ2tJUmFqjW-A/exec';
	: 'https://script.google.com/macros/s/AKfycbyeCI-HO6JEDGkePUZA_hUFkyN16s7FJLdv_lSJvcxuAYDZ1P_z6hWRK1javROcqhH0/exec';  


      if (!isGAS) {
        // 3) Stub out callServer() for local mode:
        window.google = {
          script: {
            run: {
              withSuccessHandler: fn => ({ getLastUpdateDate: () => Promise.resolve(localStorage.getItem('sheetDate') || null) }),
              withFailureHandler: () => ({})
            }
          }
        };
      }

      // 4) Replace your existing callServer() helper:
	// REPLACE broken callServer(...) with this ES5-safe version
	function callServer(fnName) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  if (!isGAS) {
		// local: stubbed behaviour for testing
		return Promise.resolve();
	  }
	  return new Promise(function(resolve, reject) {
		try {
		  // forward to google.script.run with dynamic args
		  var run = google.script.run.withSuccessHandler(resolve).withFailureHandler(reject);
		  // call .apply on the chosen server function
		  run[fnName].apply(run, args);
		} catch (e) {
		  reject(e);
		}
	  });
	}

      // ---- GAS environment detector so that index.html can be edited thru local server

    const map = L.map('map', { zoomControl: false }).setView([-7.289322, 112.676023], 16);
    //L.tileLayer('https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', { subdomains:['mt0','mt1','mt2','mt3'], attribution:'Google', maxZoom:20 }).addTo(map);
    //L.control.zoom({ position: 'topright' }).addTo(map);
    
    const sectorLayer = L.layerGroup().addTo(map);      // for permanent/normal sectors
    const tempSectorLayer = L.layerGroup().addTo(map);  // for temporary/loading sectors
          
    let currentLayer = L.tileLayer(
    'https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
    { subdomains:['mt0','mt1','mt2','mt3'], attribution:'Google', maxZoom:20 }
    ).addTo(map);    
      
    // 2. Hook up the selector
    document.getElementById('mapTypeSelect').addEventListener('change', e => {
      const lyrs = e.target.value;              // 'm'|'s'|'y'
      map.removeLayer(currentLayer);
      
      const url = 
      'https://{s}.google.com/vt/lyrs=' + lyrs +
      '&x={x}&y={y}&z={z}';
      currentLayer = L.tileLayer(url, {
        subdomains:['mt0','mt1','mt2','mt3'],
        attribution:'Google',
        maxZoom:20
      }).addTo(map);
      
    });

  const controlPanel = document.getElementById('controlPanel');
  const themeSelect=document.getElementById('themeSelect'), measureToggle=document.getElementById('measureToggle');
  const searchInput=document.getElementById('searchInput'), searchBtn=document.getElementById('searchBtn');
  const gotoInput=document.getElementById('gotoInput'), gotoBtn=document.getElementById('gotoBtn');
  const coordDisplay=document.getElementById('coordDisplay'), contextMenu=document.getElementById('contextMenu');
  const infoPopup=document.getElementById('infoPopup'), infoClose=document.getElementById('infoClose');
  const zoomSlider=document.getElementById('zoomSlider'), rangeSlider=document.getElementById('rangeSlider');
	const toggleSiteId = document.getElementById('toggleSiteId'), toggleSiteName = document.getElementById('toggleSiteName');
	const toggleAlwaysShow = document.getElementById('toggleAlwaysShow');
	const toggleSectors = document.getElementById('toggleSectors');
	const badge = document.getElementById('perfBadge');
	const clearAllBtn = document.getElementById('clearAllBtn');
	const clearPointsBtn = document.getElementById('clearPointsBtn');

  // ---------- add: helper to disable/enable sliders during loading/ISD ----------
  function setInteractiveSliders(enabled) {
    try {
      // disable/enable form controls
      rangeSlider.disabled = !enabled;
      textSizeSlider.disabled = !enabled;
      // subtle visual cue
      rangeSlider.style.opacity = enabled ? '' : '0.45';
      textSizeSlider.style.opacity = enabled ? '' : '0.45';
    } catch (e) {
      // defensive: if elements not available yet, ignore
      console.warn('setInteractiveSliders: elements missing', e);
    }
  }

  // client globals
  let sheetLastModified = null; // iso string from server

  // fetch sheet lastModified (JSONP)
  async function fetchSheetLastModified() {
    if (!SERVICE_URL) return null;
    try {
      const res = await fetchJsonp({ getLastMod: 1 });
      if (res && res.lastModified) return String(res.lastModified);
    } catch (e) { console.error('fetchSheetLastModified failed', e); }
    return null;
  }


	(function(){
		var cp  = document.getElementById('controlPanel'),
			win = window,
			inputs = [
				document.getElementById('gotoInput'),
				document.getElementById('searchInput')
			];

		inputs.forEach(function(el){
			// get original computed width as px-string and number
			var origStr = win.getComputedStyle(el).width;             // MDN:getComputedStyle
			var origNum = parseFloat(origStr);
			el.style.whiteSpace = 'pre';                              // MDN:white-space
			var handler;

			el.addEventListener('focus', function(){
			handler = function(){
				var need = el.scrollWidth + 10;                       // MDN:scrollWidth
				// don't shrink below origNum; cap at viewport
				var panelLeft = cp.getBoundingClientRect().left;
				var max     = win.innerWidth - panelLeft - 20;
				var growTo  = Math.max(origNum, need);
				// el.style.width = Math.min(growTo, max) + 'px';
			};
			handler();
			el.addEventListener('input', handler, false);
			el.addEventListener('paste', handler, false);
			}, false);

			el.addEventListener('blur', function(){
			el.removeEventListener('input', handler, false);
			el.removeEventListener('paste', handler, false);
			// el.style.width = origStr;
			}, false);
		});
		})();

	clearPointsBtn.addEventListener('click', () => {
		// gotoInput.value = '';
		clearPoints();   // your existing function that removes all pointMarkers
		
	});

	let pointMarkers = [];
	// Clear existing points
	function clearPoints() {
	  pointMarkers.forEach(m => map.removeLayer(m));
	  pointMarkers = [];
	}
	
	// current label font size (px)
	let currentTextSize = 13;
	const textSizeSlider = document.getElementById('textSizeSlider');

	textSizeSlider.addEventListener('input', e => {
	  currentTextSize = +e.target.value;
	  // instantly reflect on existing labels:
	  drawAllSectors();
	});

//related to window of search result
  // 3) Grab elements & paging constants
  var searchResultsDiv = document.getElementById('searchResults');
  var resultsList      = searchResultsDiv.querySelector('ul');
  var paginationDiv    = searchResultsDiv.querySelector('.pagination');

  var PAGE_SIZE  = 8;
  var MAX_PAGES  = 5;
  var allMatches = [];
  var currentPage = 1;

  var ctrl   = document.getElementById('controlPanel');
  var bottom = document.getElementById('bottomBar');
  var sr     = searchResultsDiv;
  let audioCtx = null;
  let hoverEnabled = true; 

  function positionSearchResults() {
    // anchor under control panel and match its width
    var rect     = ctrl.getBoundingClientRect();
    var topY     = rect.bottom + 0;
    var bottomY  = window.innerHeight - bottom.getBoundingClientRect().top + 0;
    var width    = ctrl.clientWidth;    

  //console.log('positionsearchresult1');
    // apply inline styles (overrides any CSS left/right defaults)
    sr.style.top    = topY + 'px';
    sr.style.bottom = 'auto'; 
    sr.style.width  = width + 'px';
    sr.style.left   = rect.left + 'px';  
    sr.style.right  = 'auto';

  }

  function showSearchResultsAtPanel() {
    // capture rect first (so we know the physical coordinates)
    const rect = ctrl.getBoundingClientRect();

    // collapse/hide the panel (this shows the FAB too)
    setPanelCollapsed(true);
    //console.log('showsearchresult1');
    // show and position the searchResults to match the panel's rect
    sr.style.display = 'block';
    sr.style.top    = rect.top + 'px';
    sr.style.left   = rect.left + 'px';
    sr.style.width  = rect.width + 'px';
    sr.style.bottom = 'auto';
    sr.style.right  = 'auto';
  }


  window.addEventListener('resize', positionSearchResults);
  document.addEventListener('DOMContentLoaded', positionSearchResults);

  // 4) Replace searchBtn handler
    // search — fallback to tempMemory when streaming
    searchBtn.onclick = async function() {
      const term = (searchInput.value || '').trim().toLowerCase();
      if (!term) {
        sr.style.display = 'none';
        setPanelCollapsed(false);
        return;
      }

      try {
        // 1) primary: search active DB
        let matches = await db.sites
          .filter(function(s){
            // defensive: ensure properties exist
            const sid = (s.siteId || '').toString().toLowerCase();
            const sname = (s.sitename || '').toString().toLowerCase();
            return sid.indexOf(term) !== -1 || sname.indexOf(term) !== -1;
          })
          .toArray();

        // 2) if no DB match and background streaming is active (or usingTempMemory),
        //    also check tempMemory (fast, in-memory)
        if ((!matches || matches.length === 0) && (bgRunning || usingTempMemory)) {
          const tempMatches = [];
          tempMemory.forEach(r => {
            const sid = (r.siteId || '').toString().toLowerCase();
            const sname = (r.sitename || '').toString().toLowerCase();
            if (sid.indexOf(term) !== -1 || sname.indexOf(term) !== -1) {
              tempMatches.push(r);
            }
          });
          if (tempMatches.length) {
            matches = tempMatches;
          }
        }

        allMatches = matches || [];

        if (allMatches.length === 0) {
          resultsList.innerHTML    = '<li>No results</li>';
          paginationDiv.innerHTML  = '';
          showSearchResultsAtPanel();
          return;
        }

        if (allMatches.length === 1) {
          const site = allMatches[0];
          map.setView([site.lat, site.lon], +zoomSlider.value);
          site.azimuths = (String(site.azRaw || '')).split(';')
                            .map(Number).filter(function(n){return !isNaN(n);});
          currentSites = [site];
          drawAllSectors();

          sr.style.display = 'none';
          setPanelCollapsed(false);
          return;
        }

        // multiple matches -> render list (existing behaviour)
        currentPage = 1;
        renderResults();

      } catch (err) {
        console.error('search error', err);
        resultsList.innerHTML = '<li>Error</li>';
        paginationDiv.innerHTML = '';
        showSearchResultsAtPanel();
      }
    };


  // 5) Render function
  function renderResults() {
    var start     = (currentPage - 1) * PAGE_SIZE;
    var pageItems = allMatches.slice(start, start + PAGE_SIZE);

    // build list via string-concat
    var html = '';
    for (var i = 0; i < pageItems.length; i++) {
      const t = (s, n=18) => (s && s.length>n) ? s.slice(0,n-2)+'..' : (s||'');
      var sid = pageItems[i].siteId || '';
      var sname = pageItems[i].sitename || '';
      html += '<li class="result-row" data-index="' + (start + i) + '" data-siteid="' + sid.replace(/"/g,'&quot;') + '">' +
              '<span class="siteid">' + sid + '</span>' +
              (sname ? ' <span class="sitename">' + t(sname) + '</span>' : '') +
              '</li>';
    }
    resultsList.innerHTML = html;

    // pagination
    var totalPages = Math.min(
      Math.ceil(allMatches.length / PAGE_SIZE),
      MAX_PAGES
    );
    var pagHtml = '';
    for (var p = 1; p <= totalPages; p++) {
      pagHtml += '<span class="' +
                (p === currentPage ? 'active' : '') +
                '" data-page="' + p + '">' +
                p +
                '</span>';
    }
    paginationDiv.innerHTML = pagHtml;

    // show window
    showSearchResultsAtPanel();



    // safer binding for search-result list items
    const lis = resultsList.children;
    for (let j = 0; j < lis.length; j++) {
      const li = lis[j];
      const idx = Number(li.getAttribute('data-index'));
      if (Number.isNaN(idx)) continue; // defensive

      // hover only when hoverEnabled
      li.addEventListener('pointerenter', function () {
        if (!hoverEnabled) return;
        li.classList.add('hovered');
        if (allMatches && allMatches[idx]) renderHoverSite(allMatches[idx]);
      });

      // leave: remove hovered unless pinned
      li.addEventListener('pointerleave', function () {
        if (li.classList.contains('pinned')) return;
        li.classList.remove('hovered');
      });

      // click toggles pin state
      li.addEventListener('click', function (e) {
        const alreadyPinned = li.classList.contains('pinned');

        if (alreadyPinned) {
          // unpin
          li.classList.remove('pinned');
          li.classList.remove('hovered');
          hoverEnabled = true;
          if (allMatches && allMatches[idx]) renderClickSite(allMatches[idx]);
          // hide results and restore panel
          sr.style.display = 'none';
          setPanelCollapsed(false);
        } else {
          // pin this one and unpin others
          Array.from(resultsList.children).forEach(x => x.classList.remove('pinned', 'hovered'));
          li.classList.add('pinned');
          hoverEnabled = false;
          if (allMatches && allMatches[idx]) renderClickSite(allMatches[idx]);
          // show results over the panel
          showSearchResultsAtPanel();
        }

        e.stopPropagation();
      });
    }


    // bind pagination clicks
    var spans = paginationDiv.children;
    for (var k = 0; k < spans.length; k++) {
      (function(pg){
        var span = spans[pg];
        span.addEventListener('click', function(e){
          e.stopPropagation();
          currentPage = +this.getAttribute('data-page');
          renderResults();
        });
      })(k);
    }
  }


    document.addEventListener('click', e => {
      // only auto-hide search results when hoverEnabled is true
      if (hoverEnabled) {
        if (!searchResultsDiv.contains(e.target) && e.target !== searchBtn) {
          sr.style.display = 'none';
          //setPanelCollapsed(false);          
          // also unpin any pinned rows (defensive)
          Array.from(resultsList.children).forEach(x => x.classList.remove('pinned'));
        }
      } else {
        // when pinned (hoverEnabled === false), ignore outside clicks for hiding.
        // you may optionally add logic here to unpin on some special click (not implemented).
      }

      if (!audioCtx) {
        audioCtx = new AudioContext();
        audioCtx.resume();
      }
    });

  
    // ---- replace existing renderHoverSite with this ----
    let _hoverTimer = null;
    let _lastHoverSiteId = null;

    function renderHoverSite(site) {
      // debounce quick repeated hovers
      if (!site || !site.siteId) return;
      _lastHoverSiteId = site.siteId;
      if (_hoverTimer) clearTimeout(_hoverTimer);

      _hoverTimer = setTimeout(async () => {
        // make sure this is still the latest hovered site
        if (_lastHoverSiteId !== site.siteId) return;

        // normalize azimuths (existing behavior)
        if (typeof site.azRaw === 'number') {
          site.azimuths = [ site.azRaw ];
        } else {
          const raw = String(site.azRaw || '');
          site.azimuths = raw.split(';').map(n => parseFloat(n)).filter(n => !isNaN(n));
        }

        // defensive coords
        const lat = Number(site.lat);
        const lon = Number(site.lon);
        if (!isFinite(lat) || !isFinite(lon)) {
          console.warn('renderHoverSite: invalid coords for', site.siteId);
          return;
        }

        // If ISD exists, compute bbox and fit; otherwise do a simple pan/zoom.
        const rawIsd = Number(site.ISD);
        const isdKm = (isFinite(rawIsd) && rawIsd > 0) ? rawIsd : null;

        // stop any ongoing animations so the next command is applied cleanly
        try { if (map && map._panAnim) map._panAnim.stop(); } catch(e){}

        // remove previous transient moveend handler (if any)
        if (renderHoverSite.__moveEndHandler) {
          try { map.off('moveend', renderHoverSite.__moveEndHandler); } catch(e){}
          delete renderHoverSite.__moveEndHandler;
        }

        if (isdKm) {
          // multiplier = k × ISD to each side (as requested)
          const halfExtentKm = isdKm * 1;
          try {
            const north = turf.destination([lon, lat], halfExtentKm,   0, { units: 'kilometers' }).geometry.coordinates;
            const east  = turf.destination([lon, lat], halfExtentKm,  90, { units: 'kilometers' }).geometry.coordinates;
            const south = turf.destination([lon, lat], halfExtentKm, 180, { units: 'kilometers' }).geometry.coordinates;
            const west  = turf.destination([lon, lat], halfExtentKm, 270, { units: 'kilometers' }).geometry.coordinates;

            const lats = [ north[1], east[1], south[1], west[1] ];
            const lons = [ north[0], east[0], south[0], west[0] ];
            const minLat = Math.min.apply(null, lats);
            const maxLat = Math.max.apply(null, lats);
            const minLon = Math.min.apply(null, lons);
            const maxLon = Math.max.apply(null, lons);

            const bounds = [[minLat, minLon], [maxLat, maxLon]];

            // Wait for moveend to draw so drawAllSectors doesn't race and trigger other behaviors
            renderHoverSite.__moveEndHandler = function() {
              // only draw if the hovered site remains the same
              if (_lastHoverSiteId === site.siteId) {
                currentSites = [site];
                drawAllSectors();
              }
              // cleanup
              map.off('moveend', renderHoverSite.__moveEndHandler);
              delete renderHoverSite.__moveEndHandler;
            };
            map.once('moveend', renderHoverSite.__moveEndHandler);

            // fit bounds (no immediate setView before this)
            map.fitBounds(bounds, { padding: [20,20], animate: true, maxZoom: 18 });

          } catch (err) {
            console.warn('renderHoverSite: turf destination failed — fallback to setView', err);
            // fallback to simple centering
            currentSites = [site];
            map.setView([lat, lon], +zoomSlider.value);
            drawAllSectors();
          }
        } else {
          // no ISD: behave like normal single-site pan/zoom, but still debounce
          currentSites = [site];
          map.setView([lat, lon], +zoomSlider.value);
          drawAllSectors();
        }
      }, 120); // 120ms debounce — adjust if you want faster/slower responsiveness
    }

  function renderClickSite(site) {
      if (typeof site.azRaw === 'number') {
      // single numeric value → treat as one “sector”
      site.azimuths = [ site.azRaw ];
      } else {
      // now safely coerce to string:
      const raw = String(site.azRaw||'');
      site.azimuths = raw
        .split(';')
        .map(n => parseFloat(n))
        .filter(n => !isNaN(n));
      }
    
      map.setView([site.lat, site.lon], +zoomSlider.value);
      currentSites = [site];
      drawAllSectors();

  }

  // 1) Clear all button
  clearAllBtn.addEventListener('click', function() {
    // clear drawn sectors & markers
    clearSectors();
    // reset model
    currentSites = [];
    // hide search window if open
    sr.style.display = 'none';
    setPanelCollapsed(false);
  });

  // 2) Redraw on toggleSectors change
  toggleSectors.addEventListener('change', drawAllSectors);

  // 3) Redraw when toggleSiteId or toggleSiteName change
  var toggles = [toggleSiteId, toggleSiteName];
  for (var i = 0; i < toggles.length; i++) {
    toggles[i].addEventListener('change', function() {
      drawAllSectors();
    });
  }

  function updateVisibleSites() {
    const b = map.getBounds();
    const bbox = [b.getSouth(), b.getWest(), b.getNorth(), b.getEast()];
    if (!toggleAlwaysShow.checked) {
      clearSectors();
      currentSites = [];
      return;
    }
    // If background streaming active use tempMemory first and also attempt a quick server fetch
    if (bgRunning) {
      // 1) immediate render from tempMemory (fast)
      const fromTemp = tempRowsInBBox(bbox);
      if (fromTemp.length) {
        // normalize azimuth parsing like other flows
        fromTemp.forEach(r => {
          if (typeof r.azRaw === 'number') r.azimuths = [r.azRaw];
          else {
            const raw = String(r.azRaw || '');
            r.azimuths = raw.split(';').map(n => parseFloat(n)).filter(n => !isNaN(n));
          }
        });
        currentSites = fromTemp;
        drawAllSectors();
      } else {
        // // clear currentSites if nothing in tempMemory within bbox
        // currentSites = [];
        // drawAllSectors();
      }

      // 2) fire-and-forget quick server fetch for precise/updated results in viewport
      // limit small so it returns fast (e.g. 1000)
      fetchJsonp({ fetchData: 1, bbox: bbox.join(','), limit: 200 })
        .then(rows => {
          if (!bgRunning) return;
          if (typeof toggleSectors !== 'undefined' && !toggleSectors.checked) {
            // still persist but do not draw
            upsertSites(rows).catch(()=>{});
            return;
          }

          if (rows && rows.length) {
            // add to temp memory (and to DB via upsertSites)
            addToTemp(rows);
            // update view with merged tempMemory results
            const merged = tempRowsInBBox(bbox);
            merged.forEach(r => {
              if (typeof r.azRaw === 'number') r.azimuths = [r.azRaw];
              else {
                const raw = String(r.azRaw || '');
                r.azimuths = raw.split(';').map(n => parseFloat(n)).filter(n => !isNaN(n));
              }
            });
            currentSites = merged;
            drawAllSectors();
            // persist rows (non-blocking)
            upsertSites(rows).catch(()=>{});
          }
        })
        .catch(() => {/* silent fallback */});

      return;
    }

    // When not streaming, fall back to DB query (original logic)
    db.sites
      .where('lat').between(b.getSouth(), b.getNorth())
      .and(function(s) {
        return s.lon >= b.getWest() && s.lon <= b.getEast();
      })
      .toArray()
      .then(function(rows) {
        for (var j = 0; j < rows.length; j++) {
          var r = rows[j];
          if (typeof r.azRaw === 'number') {
            r.azimuths = [ r.azRaw ];
          } else {
            var raw = String(r.azRaw || '');
            var parts = raw.split(';');
            var azs = [];
            for (var k = 0; k < parts.length; k++) {
              var num = parseFloat(parts[k]);
              if (!isNaN(num)) {
                azs.push(num);
              }
            }
            r.azimuths = azs;
          }
        }
        currentSites = rows;
        drawAllSectors();
      });
  }


  // 5) Bind updateVisibleSites to map events
  map.on('moveend', updateVisibleSites);
  map.on('zoomend', updateVisibleSites);

  // 6) When toggleAlwaysShow changes
  toggleAlwaysShow.addEventListener('change', function() {
    clearSectors();
    updateVisibleSites();
  });


    // ---------- NEW panel toggle behaviour (replace previous collapseBtn.onclick / toggleBtn.onclick) ----------
    const collapseBtn = document.getElementById('collapseBtn');
    const toggleBtn = document.getElementById('toggle-panel');
    

    function setPanelCollapsed(collapsed){
      if (collapsed) {
        controlPanel.classList.add('collapsed');
        toggleBtn.style.display = 'flex';
        toggleBtn.setAttribute('aria-expanded','false');
      } else {
        controlPanel.classList.remove('collapsed');
        toggleBtn.style.display = 'none';
        toggleBtn.setAttribute('aria-expanded','true');
      }
      requestSaveUI(); // persist change to indexedDB
    }

    // new — stop propagation so global document click handler won't undo the action
    collapseBtn.addEventListener('click', function (e) {
      e.stopPropagation();
      setPanelCollapsed(true);
    });
    toggleBtn.addEventListener('click', function (e) {
      e.stopPropagation();
      setPanelCollapsed(false);
    });
    

    // show FAB on small screens initially (non-saved)
    if (window.matchMedia('(max-width:640px)').matches) {
      // when mobile, keep panel visible but show FAB if collapsed state will be set later
      toggleBtn.style.display = controlPanel.classList.contains('collapsed') ? 'flex' : 'none';
    }

    //const sites=[{siteid:'SITE-1',sitename:'Central Jakarta Node',lat:-6.2,lng:106.816,azimuths:[60,180,300]}];
    const sectorHalfAngle=20; let range=100, currentTheme='1';
    let siteColors={}, sectorLayers={};
    let siteMarkers = [];
    let currentSites = [];
    let siteMarkersById = {}; // NEW: map siteId -> {outer, middle, circle, marker}

    let measureMode=false, refPoint=null, measureLine=null, measureMarker=null;


    // 1) Constants
    const DIST_KM = 3, BW_HALF = 100/2;

    // 2) Setup Dexie DB — dual-buffer (active / inactive)
    const DB_A_NAME = 'SiteDB';
    const DB_B_NAME = 'SiteDB2';

    // create both Dexie instances (same schema)
    const dbA = new Dexie(DB_A_NAME);
    dbA.version(1).stores({ sites: 'siteId, sitename, lon, lat, azRaw' });

    const dbB = new Dexie(DB_B_NAME);
    dbB.version(1).stores({ sites: 'siteId, sitename, lon, lat, azRaw' });

    // active DB selection persisted across reloads
    let activeDbName = localStorage.getItem('activeSiteDB') || DB_A_NAME;
    let activeDb = (activeDbName === DB_A_NAME) ? dbA : dbB;
    let inactiveDb = (activeDb === dbA) ? dbB : dbA;

    // convenience reference used by the rest of the code
    let db = activeDb;

    // when a background load is running we will write into `targetDb` (the inactive one)
    let targetDb = null;


    // temporary in-memory store while background download is running
    const tempMemory = new Map(); // key = siteId, value = row object
    let usingTempMemory = true;   // true while download not finished


    /* --- UI state save/load (minimal IndexedDB) --- */
    const _uiDBName = 'NDB_UI_Settings_v1';
    const _uiStoreKey = 'ui';
    function _openUIDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(_uiDBName, 1);
        req.onupgradeneeded = e => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains('settings')) db.createObjectStore('settings');
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }
    async function saveUISettings(obj) {
      try {
        const db = await _openUIDB();
        const tx = db.transaction('settings', 'readwrite');
        tx.objectStore('settings').put(obj, _uiStoreKey);
        await new Promise(r => { tx.oncomplete = r; tx.onerror = () => r(); });
        db.close();
      } catch (e) { console.warn('saveUISettings failed', e); }
    }
    async function loadUISettings() {
      try {
        const db = await _openUIDB();
        const tx = db.transaction('settings', 'readonly');
        const req = tx.objectStore('settings').get(_uiStoreKey);
        const v = await new Promise(r => { req.onsuccess = () => r(req.result); req.onerror = () => r(null); });
        db.close();
        return v || null;
      } catch (e) { console.warn('loadUISettings fail', e); return null; }
    }
function gatherUISettings() {
  const c = map.getCenter();
  return {
    center: { lat: c.lat, lng: c.lng },
    zoom: map.getZoom(),
    themeSelect: themeSelect.value,
    mapType: mapTypeSelect.value,
    range: +rangeSlider.value,
    zoomSlider: +zoomSlider.value,
    textSize: +textSizeSlider.value,
    toggleAlwaysShow: !!toggleAlwaysShow.checked,
    toggleSectors: !!toggleSectors.checked,
    toggleSiteId: !!toggleSiteId.checked,
    toggleSiteName: !!toggleSiteName.checked,
    // measureMode: !!measureToggle.checked,
    panelCollapsed: controlPanel.classList.contains('collapsed')  // new
  };
}
    let _saveTimer = null;
    function requestSaveUI() {
      if (_saveTimer) clearTimeout(_saveTimer);
      _saveTimer = setTimeout(() => { _saveTimer = null; saveUISettings(gatherUISettings()); }, 250);
    }
    /* wire controls to requestSaveUI */
    themeSelect.addEventListener('change', requestSaveUI);
    mapTypeSelect.addEventListener('change', requestSaveUI);
    rangeSlider.addEventListener('input', requestSaveUI);
    zoomSlider.addEventListener('input', requestSaveUI);
    textSizeSlider.addEventListener('input', () => { requestSaveUI(); drawAllSectors(); });
    toggleAlwaysShow.addEventListener('change', requestSaveUI);
    
    toggleSectors.addEventListener('change', () => {
      requestSaveUI();
      // if unchecked, clear both temp and permanent sector layers immediately
      if (!toggleSectors.checked) {
        try { tempSectorLayer.clearLayers(); } catch (e) {}
        try { sectorLayer.clearLayers(); } catch (e) {}
        return;
      }
      // if checked, redraw
      drawAllSectors();
    });

    toggleSiteId.addEventListener('change', () => { requestSaveUI(); drawAllSectors(); });
    toggleSiteName.addEventListener('change', () => { requestSaveUI(); drawAllSectors(); });
    // measureToggle.addEventListener('change', requestSaveUI);
    map.on('moveend', requestSaveUI);
    map.on('zoomend', requestSaveUI);
    async function applySavedUI() {
      const s = await loadUISettings();
      if (!s) return;
      try {
        if (s.themeSelect) { themeSelect.value = s.themeSelect; themeSelect.dispatchEvent(new Event('change')); }
        if (s.mapType) { mapTypeSelect.value = s.mapType; mapTypeSelect.dispatchEvent(new Event('change')); }
        if (typeof s.range !== 'undefined') { rangeSlider.value = s.range; range = +s.range; drawAllSectors(); }
        if (typeof s.textSize !== 'undefined') { textSizeSlider.value = s.textSize; currentTextSize = +s.textSize; drawAllSectors(); }
        if (typeof s.toggleAlwaysShow !== 'undefined') toggleAlwaysShow.checked = !!s.toggleAlwaysShow;
        if (typeof s.toggleSectors !== 'undefined') toggleSectors.checked = !!s.toggleSectors;
        if (typeof s.toggleSiteId !== 'undefined') toggleSiteId.checked = !!s.toggleSiteId;
        if (typeof s.toggleSiteName !== 'undefined') toggleSiteName.checked = !!s.toggleSiteName;
        // if (typeof s.measureMode !== 'undefined') measureToggle.checked = !!s.measureMode;
        if (s.center && typeof s.zoom !== 'undefined') {
          map.setView([s.center.lat, s.center.lng], s.zoom);
          zoomSlider.value = s.zoom;
        } else if (typeof s.zoom !== 'undefined') {
          map.setZoom(s.zoom); zoomSlider.value = s.zoom;
        }
// after existing applySavedUI assignments:
if (typeof s.panelCollapsed !== 'undefined') {
  setPanelCollapsed(!!s.panelCollapsed);
} else {
  // default: show panel on desktop, allow FAB on mobile
  if (window.matchMedia('(max-width:640px)').matches) toggleBtn.style.display = 'flex';
  else toggleBtn.style.display = 'none';
}


      } catch (e) { console.warn('applySavedUI failed', e); }
    }


    
    async function computeISD(k = 3, progressCb) {
      //console.log('computeISD: start');
      const rows = await db.sites.toArray();
      const N = rows.length;
      if (N === 0) {
        //console.log('computeISD: no rows');
        if (progressCb) progressCb(0,0);
        return;
      }

      // detect RBush implementation
      const RB = window.rbush || window.RBush || window.RBush || window.RBush || (typeof rbush !== 'undefined' && rbush) || null;
      let tree = null;
      if (RB) {
        try {
          tree = new RB();
          const items = rows.map(r => ({
            minX: Number(r.lon) || 0, minY: Number(r.lat) || 0,
            maxX: Number(r.lon) || 0, maxY: Number(r.lat) || 0,
            siteId: r.siteId
          }));
          tree.load(items);
        } catch (e) {
          console.warn('computeISD: rbush init failed, falling back to brute-force', e);
          tree = null;
        }
      } else {
        console.warn('computeISD: rbush not found, using O(N^2) fallback');
      }

      const out = [];
      for (let i = 0; i < N; i++) {
        const a = rows[i];
        // defensive normalisation
        a.lon = Number(a.lon);
        a.lat = Number(a.lat);
        if (!isFinite(a.lon) || !isFinite(a.lat)) {
          a.ISD = 0;
          out.push(a);
          if (progressCb && i % 50 === 0) progressCb(i+1, N);
          continue;
        }

        const dists = [];
        if (tree) {
          // expand search box until we have enough neighbours
          let half = 0.01; // ~1km at equator ~ not exact but for initial probe
          while (half < 180) {
            const found = tree.search({
              minX: a.lon - half, minY: a.lat - half,
              maxX: a.lon + half, maxY: a.lat + half
            }).filter(f => String(f.siteId) !== String(a.siteId));

            if (found.length >= k || half > 90) {
              for (const f of found) {
                // turf.distance expects [lng,lat]
                try {
                  const km = turf.distance([a.lon, a.lat], [f.minX, f.minY], { units: 'kilometers' });
                  if (!isNaN(km)) dists.push(km);
                } catch (e) { /* ignore single error */ }
              }
              break;
            }
            half *= 2;
          }
        } else {
          // brute-force
          for (let j = 0; j < N; j++) {
            if (i === j) continue;
            const b = rows[j];
            const blon = Number(b.lon), blat = Number(b.lat);
            if (!isFinite(blon) || !isFinite(blat)) continue;
            try {
              const km = turf.distance([a.lon, a.lat], [blon, blat], { units: 'kilometers' });
              if (!isNaN(km)) dists.push(km);
            } catch (e) {}
          }
        }

        dists.sort((x,y) => x-y);
        const pick = dists.slice(0, k);
        a.ISD = pick.length ? (pick.reduce((s,v)=>s+v,0) / pick.length) : 0;
        out.push(a);

        if (progressCb && (i % 100 === 0 || i === N-1)) progressCb(i+1, N);
        // yield occasionally so UI doesn't lock
        if (i % 200 === 0) await new Promise(r=>setTimeout(r,0));
      }

      // persist
      try {
        await db.sites.bulkPut(out);
        //console.log('computeISD: bulkPut done for', out.length);
      } catch (e) {
        //console.warn('computeISD: bulkPut failed, falling back to per-row put', e);
        for (const r of out) {
          try { await db.sites.put(r); } catch(_) {}
        }
        //console.log('computeISD: per-row put done');
      }
      if (progressCb) progressCb(N, N);
      console.log('computeISD: finished');
    }








    // Build GeoJSON “vectors” based on ISD
    async function loadVectors() {
      const raw = await db.sites.toArray();
      return raw.flatMap(r => {
        try {
          
          // use ISD (km) if present; otherwise fallback to 3 km
          const D = (Number(r.ISD) && isFinite(Number(r.ISD)) ? Number(r.ISD) : 3) * 2;

          return String(r.azRaw ?? '').split(';')
            .map(a=>parseFloat(a))
            .filter(azi=>!isNaN(azi))
            .map(azi => turf.polygon([[
              [r.lon, r.lat],
              turf.destination([r.lon, r.lat], D, azi - BW_HALF, { units:'kilometers' }).geometry.coordinates,
              turf.destination([r.lon, r.lat], D, azi + BW_HALF, { units:'kilometers' }).geometry.coordinates,
              [r.lon, r.lat]
            ]], { siteId: r.siteId }));
        } catch (e) {
          console.error('Error building vectors for', r.siteId, r);
          throw e;   // re-throw so you still see the turf error stack
        }
      });
    }


    // 6) Pure‑client getNeighbors
    function getNeighborsClient(targetSiteId) {
      const tree = geojsonRbush();
      tree.load({ type: 'FeatureCollection', features: vectors });
      const result = new Set();
      vectors
        .filter(f=>f.properties.siteId===targetSiteId)
        .forEach(tgt=>{
          (tree.search(tgt).features||[])
            .filter(f=>f.properties.siteId!==targetSiteId)
            .forEach(f=>{
              if (turf.booleanIntersects(tgt, f)) {
                result.add(f.properties.siteId);
              }
            });
        });
      return [...result];
    }

    // 7) Wire it up 
    let vectors = [];

    /* ============================
       Client incremental loader
       Replace previous JSONP + eager load functions
       ============================ */

    // JSONP helper returning Promise
	// REPLACE existing fetchJsonp() with this safer, defensive version
	function fetchJsonp(params) {
	  return new Promise(function(resolve, reject) {
		try {
		  // if SERVICE_URL not set, do not try JSONP (local mode fallback).
		  if (!SERVICE_URL || typeof SERVICE_URL !== 'string' || SERVICE_URL.trim() === '') {
			resolve([]);
			return;
		  }

		  // build callback name
		  var cbName = 'cb_' + Math.random().toString(36).slice(2);

		  // create a safe script reference holder
		  var script = null;

		  // register global callback
		  window[cbName] = function(data) {
			try { delete window[cbName]; } catch (e) {}
			if (script && script.parentNode) script.parentNode.removeChild(script);
			resolve(data);
		  };

		  // build query string: guard undefined/null => empty string
		  var paramsObj = params || {};
		  var keys = Object.keys(paramsObj);
		  var qs = keys.map(function(k) {
			var v = paramsObj[k];
			if (v === undefined || v === null) v = '';
			return encodeURIComponent(k) + '=' + encodeURIComponent(String(v));
		  }).join('&');

		  var sep = (SERVICE_URL.indexOf('?') !== -1) ? '&' : '?';
		  var url = SERVICE_URL + sep + qs + '&callback=' + cbName;

		  // Defensive: do not attempt to load non-http(s) URLs (prevents file:///undefined)
		  if (!/^https?:\/\//i.test(url)) {
			try { delete window[cbName]; } catch (e) {}
			resolve([]); // graceful fallback for local/file:// testing
			return;
		  }

		  // create script tag
		  script = document.createElement('script');
		  script.async = true;
		  script.src = url;

		  script.onerror = function(e) {
			try { delete window[cbName]; } catch (err) {}
			if (script && script.parentNode) script.parentNode.removeChild(script);
			reject(new Error('JSONP load error for ' + url));
		  };

		  // append and let network do its job
		  (document.head || document.documentElement).appendChild(script);

		} catch (ex) {
		  try { delete window[cbName]; } catch (e) {}
		  reject(ex);
		}
	  });
	}


    // Fetch sites inside current viewport (bbox)
    async function fetchViewportSites() {
      const b = map.getBounds();
      const minLat = b.getSouth();
      const minLon = b.getWest();
      const maxLat = b.getNorth();
      const maxLon = b.getEast();
      // Call server with bbox; limit optional (use 5000 safe cap)
      const params = { fetchData: 1, bbox: [minLat, minLon, maxLat, maxLon].join(','), limit: 5000 };
      const rows = await fetchJsonp(params);
      return rows || [];
    }

    // Background paginated streamer
    const BG_BATCH = 400;        // rows per server fetch. Tune lower if you hit GAS limits.
    const BG_DELAY_MS = 300;     // delay between batches to yield UI
    let bgNextStart = parseInt(localStorage.getItem('bgNextStart') || '0', 10);
    let bgRunning = false;

    async function fetchBatch(start, limit) {
      const params = { fetchData: 1, start: start, limit: limit };
      const rows = await fetchJsonp(params);
      return rows || [];
    }

    async function upsertSites(rows) {
      if (!rows || rows.length === 0) return;
      rows.forEach(r => {
        r.lon = Number(r.lon);
        r.lat = Number(r.lat);
        if (typeof r.azRaw === 'undefined' || r.azRaw === null) r.azRaw = '';
      });

      // write to temp memory immediately so UI can render during streaming
      addToTemp(rows);

      // choose destination DB:
      // - if `targetDb` is set (we are streaming into inactive DB), write there
      // - otherwise write into the current active `db`
      const writeDb = targetDb || db;

      try {
        await writeDb.sites.bulkPut(rows);
      } catch (e) {
        // fallback to per-row put on error
        for (const r of rows) {
          try { await writeDb.sites.put(r); } catch (ee) { /* ignore individual failures */ }
        }
      }
    }



    function addToTemp(rows) {
      if (!rows || rows.length === 0) return;
      rows.forEach(r => {
        // normalize same as upsert
        r.lon = Number(r.lon);
        r.lat = Number(r.lat);
        if (typeof r.azRaw === 'undefined' || r.azRaw === null) r.azRaw = '';
        tempMemory.set(String(r.siteId), r);
      });
    }
    function clearTemp() {
      tempMemory.clear();
      if (typeof tempSectorLayer !== 'undefined') tempSectorLayer.clearLayers();
      if (typeof sectorLayer !== 'undefined') sectorLayer.clearLayers();      
    }
    function tempRowsInBBox(bbox) {
      // bbox = [minLat,minLon,maxLat,maxLon]
      const minLat = Math.min(bbox[0], bbox[2]);
      const maxLat = Math.max(bbox[0], bbox[2]);
      const minLon = Math.min(bbox[1], bbox[3]);
      const maxLon = Math.max(bbox[1], bbox[3]);
      const out = [];
      tempMemory.forEach(r => {
        if (!r || isNaN(r.lat) || isNaN(r.lon)) return;
        if (r.lat >= minLat && r.lat <= maxLat && r.lon >= minLon && r.lon <= maxLon) out.push(r);
      });
      return out;
    }


    // add these helpers
    let totalRows = null; // server-provided total rows (may be null if fetch fails)

    function updatePerfBadge(status, downloaded, total) {
      const pct = (total && total > 0) ? Math.min(100, Math.round((downloaded / total) * 100)) : null;
      const parts = [];
      parts.push(status);
      // parts.push(downloaded + ' rows');
      // if (total !== null) parts.push('of ' + total);
      if (pct !== null) parts.push('(' + pct + '%)');
      if (status != 'finished') {
          badge.textContent = parts.join(' · ');
      }
      
      // color mapping
      if (status === 'finished') {
        badge.textContent = '';
        badge.style.background = 'rgba(0,128,0,0.7)';
      }
      else if (status === 'paused') badge.style.background = 'rgba(255,165,0,0.7)';
      else if (status === 'loading') badge.style.background = 'rgba(0,122,255,0.8)';
      else badge.style.background = 'rgba(0,0,0,0.5)';
    }

    async function fetchTotalCount() {
      if (!SERVICE_URL) return null;
      try {
        const res = await fetchJsonp({ getTotal: 1 });
        if (res && typeof res.total !== 'undefined') return Number(res.total);
      } catch (e) {
        console.error('fetchTotalCount failed', e);
      }
      return null;
    }

    
	async function backgroundLoader() {
	  // don't restart if already running
	  if (bgRunning) return;

	  // require a SERVICE_URL for background streaming (safety)
	  if (!SERVICE_URL) {
		console.warn('backgroundLoader aborted: SERVICE_URL not set');
		return;
	  }
		console.info('backgroundLoader starting; SERVICE_URL=', SERVICE_URL, 'bgNextStart=', bgNextStart);
		
	  bgRunning = true;
	  setInteractiveSliders(false);


      // --- start streaming into the inactive DB so active DB stays live ---
      // pick inactive DB as target and wipe it before writing new rows
      try {
        targetDb = inactiveDb;
        await targetDb.sites.clear(); // start fresh in the inactive DB
        console.log('backgroundLoader: target DB cleared:', (targetDb === dbA) ? DB_A_NAME : DB_B_NAME);
      } catch (e) {
        console.warn('backgroundLoader: could not clear target DB, continuing', e);
        // if clearing fails we still continue (best-effort)
        targetDb = inactiveDb;
      }



      // try get total once upfront (best-effort)
      totalRows = await fetchTotalCount();

      // start/resume label
      const initialStatus = (bgNextStart && bgNextStart > 0) ? 'resumed' : 'please wait';
      updatePerfBadge(initialStatus, bgNextStart, totalRows);

      // 1) Fetch immediate viewport so user sees visible sites fast
      try {
        const vpRows = await fetchViewportSites();
        if (vpRows && vpRows.length) {
          await upsertSites(vpRows);
          // account vpRows as downloaded for badge
          
          bgNextStart += vpRows.length;
          localStorage.setItem('bgNextStart', String(bgNextStart));            

          updatePerfBadge('loading', bgNextStart, totalRows);
          updateVisibleSites(); // draw current visible ones
        }
      } catch (e) {
        console.error('viewport fetch failed', e);
      }

      // 2) Continue with paginated background streaming (start/limit)
      while (true) {
        await new Promise(resolveIdle => {
          if ('requestIdleCallback' in window) {
            requestIdleCallback(resolveIdle, { timeout: 1000 });
          } else {
            setTimeout(resolveIdle, 0);
          }
        });

        if (!bgRunning) break;

        try {
          const batch = await fetchBatch(bgNextStart, BG_BATCH);
          if (!batch || batch.length === 0) {
            // finished full table
            localStorage.removeItem('bgNextStart');
            // mark finished
            updatePerfBadge('finished', bgNextStart, totalRows);
            break;
          }

          await upsertSites(batch);
          bgNextStart += batch.length;
          localStorage.setItem('bgNextStart', bgNextStart.toString());

          // update badge after successful batch
          updatePerfBadge('loading', bgNextStart, totalRows);

          // yield to UI between batches
          await new Promise(r => setTimeout(r, BG_DELAY_MS));
        } catch (err) {
          console.error('background batch error', err);
          updatePerfBadge('paused', bgNextStart, totalRows);
          // back off on error
          await new Promise(r => setTimeout(r, 2000));
        }
      }

      bgRunning = false;
      // if we stopped but not finished, show paused (unless finished handled above)
      if (totalRows !== null && bgNextStart < totalRows) {
        updatePerfBadge('paused', bgNextStart, totalRows);
      } else if (totalRows === null) {
        // unknown total: show stopped with downloaded count
        updatePerfBadge('finished', bgNextStart, totalRows);
      } else {
        updatePerfBadge('finished', bgNextStart, totalRows);
      }

      // when no more batches:
      localStorage.removeItem('bgNextStart');
      // mark finished in UI
      updatePerfBadge('finished', bgNextStart, totalRows);
      
      // fully finished: stop streaming into targetDb and atomically swap active DB
      bgRunning = false;
      usingTempMemory = false;

      // give final writes a moment to settle
      await new Promise(r => setTimeout(r, 200));

      try {
        // swap active DB if a target was used
        if (targetDb) {
          // swap logical pointers
          activeDb = targetDb;
          db = activeDb;
          inactiveDb = (activeDb === dbA) ? dbB : dbA;

          // persist which DB is active
          const activeName = (activeDb === dbA) ? DB_A_NAME : DB_B_NAME;
          localStorage.setItem('activeSiteDB', activeName);
          console.log('backgroundLoader: swapped active DB to', activeName);

          // clear targetDb pointer so future writes go to active db
          targetDb = null;
        }

        // -------------------------
        // Recompute ISD if needed on the NEW active DB
        // (this ensures ISD is computed against freshly-loaded data)
        // -------------------------
        try {
          const need = await db.sites.filter(r => typeof r.ISD !== 'number' || isNaN(r.ISD)).count();
          if (need > 0) {
            await computeISD(3, (d, t) => updatePerfBadge('computing ISD ' + d + '/' + t, d, t));
            updatePerfBadge('finished', bgNextStart, totalRows);
          }
        } catch (e) {
          console.error('ISD compute check failed', e);
        }

        // IMMEDIATE cleanup: remove any temp layers from map so DB redraw starts clean
        try {
          clearSectors();   // remove polygons/markers created from tempMemory
        } catch (e) {
          console.warn('backgroundLoader: clearSectors() failed', e);
        }

        // rebuild vectors and redraw from the (now) active DB
        try {
          vectors = await loadVectors();
        } catch (e) {
          console.error('loadVectors after finish failed', e);
          vectors = [];
        }
        updateVisibleSites();

        // persist server timestamp as the authoritative stamp
        if (sheetLastModified) {
          localStorage.setItem('sheetDate', sheetLastModified);
        } else {
          localStorage.setItem('sheetDate', new Date().toISOString());
        }

      } catch (e) {
        console.error('backgroundLoader finalization failed', e);
      } finally {
        setInteractiveSliders(true);
        updatePerfBadge('finished', bgNextStart, totalRows);
        localStorage.removeItem('bgNextStart');
      }
    }


    async function ensureDataUpToDate() {
      let loadingLabel = document.getElementById('loadingLabel');
      if (!loadingLabel) {
        loadingLabel = document.createElement('div');
        loadingLabel.id = 'loadingLabel';

        // --- dynamic message by time ---
        const hour = new Date().getHours();
        let msg = 'loading visible sites…'; // fallback

        if (hour >= 4 && hour < 7) {
          msg = 'wih pagi2 udah kerja.. semangat kk..';
        } else if (hour >= 7 && hour < 10) {
          msg = 'pagi kk..';
        } else if (hour >= 10 && hour < 14) {
          msg = 'siang kk..';
        } else if (hour >= 14 && hour < 16) {
          msg = 'siang kk.. udah makan blm nih?';
        } else if (hour >= 16 && hour < 18) {
          msg = 'semangat kk..';
        } else if (hour >= 18 && hour < 22) {
          msg = 'udah kk..isitrahat dulu';
        } else {
          // covers 22:00–24:00 and 0:00–4:00
          msg = 'ya ampun kk.. masih kerja aja nih?';
        }

        loadingLabel.textContent = msg;
        // --- end dynamic message ---

        document.body.appendChild(loadingLabel);
      }
      loadingLabel.style.display = 'block';
      setInteractiveSliders(false);
      try {
        // 0) ask server for lastModified (best-effort)
        sheetLastModified = await fetchSheetLastModified();

        // 1) compare with stored value in indexDB/localStorage
        const localStamp = localStorage.getItem('sheetDate') || null;

        if (sheetLastModified && localStamp === sheetLastModified) {
          // considered finished. skip background download and use indexDB as source.
          usingTempMemory = false;

          // IMMEDIATE cleanup if we already have DB cached:
          try { clearTemp(); } catch(e){ console.warn('ensureDataUpToDate: clearTemp failed', e); }
          try { clearSectors(); } catch(e){ console.warn('ensureDataUpToDate: clearSectors failed', e); }

          // ensure DB has data; if empty fallback to a viewport fetch
          const cnt = await db.sites.count();
          if (cnt === 0) {
            const vp = await fetchViewportSites();
            if (vp && vp.length) await upsertSites(vp);
          }
          // build vectors from DB and draw
          try { vectors = await loadVectors(); } catch(e){ vectors = []; console.error(e); }
          updateVisibleSites();

          try {
            const need = await db.sites.filter(r => typeof r.ISD !== 'number' || isNaN(r.ISD)).count();
            if (need > 0) {
              await computeISD(3, (d,t)=> updatePerfBadge('computing ISD ' + d + '/' + t, d, t));
              updatePerfBadge('finished', bgNextStart, totalRows);
            }
          } catch (e) { console.error('ISD compute check failed', e); }

          return; // no download
        }

        // Not same or unknown -> proceed with existing logic (download)
        const cnt = await db.sites.count();
        if (cnt === 0) {
          const vp = await fetchViewportSites();
          if (vp && vp.length) {
            await upsertSites(vp);
            updateVisibleSites();
          }
        } else {
          updateVisibleSites();
        }
      } catch (e) {
        console.error('ensureDataUpToDate initial fetch failed', e);
      } finally {
        setInteractiveSliders(true);
        loadingLabel.style.display = 'none';
      }

      // schedule background streaming as before
      if ('requestIdleCallback' in window) requestIdleCallback(backgroundLoader);
      else setTimeout(backgroundLoader, 500);
    }



    document.addEventListener('DOMContentLoaded', async () => {
      await applySavedUI();        // <--- NEW: restore UI state before data load
      ensureDataUpToDate();

      // decide if we need to compute ISD: count rows missing a usable ISD
      try {
        const total = await db.sites.count();
        let needISD = false;
        if (total > 0) {
          const missing = await db.sites.filter(r => !(typeof r.ISD === 'number' && isFinite(r.ISD) && r.ISD > 0)).count();
          needISD = missing > 0;
        }
        if (needISD) {
          // disable interactive sliders while heavy ISD compute runs
          setInteractiveSliders(false);
          // show quick progress in badge while computing
          await computeISD(3, (done, tot) => updatePerfBadge('ISD', done, tot));
          // re-enable after compute finishes
          setInteractiveSliders(true);
          updatePerfBadge('finished', bgNextStart, totalRows);
        }
      } catch (e) {
        console.error('ISD compute check failed', e);
      }

      try {
        vectors = await loadVectors();
      } catch (e) {
        console.error('initial loadVectors error', e);
        vectors = [];
      }
    });






    function clearSectors() {
      // 1) Remove every polygon from the map      
      // console.log('Clearing sectors from:', Object.keys(sectorLayers));
      Object.values(sectorLayers).forEach(layerArray => {
        layerArray.forEach(layer => map.removeLayer(layer));
      });
      
      // 2) Reset your container
      sectorLayers = {};
    
      siteMarkers.forEach(marker => map.removeLayer(marker));
      siteMarkers = [];

      // NEW: also clear the id-index so future draws can be created again
      siteMarkersById = {};      

      if (typeof tempSectorLayer !== 'undefined') tempSectorLayer.clearLayers();
      if (typeof sectorLayer !== 'undefined') sectorLayer.clearLayers();


    }

    // ES5‐compatible drawSingleSite
    function drawSingleSite(site) {

      if (siteMarkersById[site.siteId]) return;

      // build label parts
      var parts = [];
      if (toggleSiteId.checked) {
        parts.push('<b>' + site.siteId + '</b>');
      }
      if (toggleSiteName.checked) {
        parts.push('<br>'+ site.sitename);
      }

      var outer = L.circleMarker([site.lat, site.lon], {
        radius: 5,
        color: 'white',
        weight: 3,
        fillOpacity: 0,
        interactive: false
      }).addTo(map);

      var middle = L.circleMarker([site.lat, site.lon], {
        radius: 4,
        color: 'black',
        weight: 2,
        fillOpacity: 0,
        interactive: false
      }).addTo(map);

      var circle = L.circleMarker([site.lat, site.lon], {
        radius: 2,
        color: 'hsl(219,100%,50%)',
        fillColor: 'hsl(219,100%,50%)',
        fillOpacity: 1,
        weight: 1,
        interactive: false
      }).addTo(map);

      // build HTML for label using string concatenation
      var labelHtml = '<span style="font-size:' +
                      currentTextSize +
                      'px;">' +
                      parts.join(' ') +
                      '</span>';

      // draw div icon marker
      var marker = L.marker([site.lat, site.lon], {
        icon: L.divIcon({
          className: 'bts-label',
          html: labelHtml,
          iconAnchor: [0, 0]
        })
      }).addTo(map);

      // store for later removal
      // siteMarkers.push(circle);
      // siteMarkers.push(marker);

      // --- STORE ALL LAYERS (NEW) ---
      siteMarkers.push(outer, middle, circle, marker);
      siteMarkersById[site.siteId] = {
        outer: outer,
        middle: middle,
        circle: circle,
        marker: marker
      };
            
    }


  function drawSingleSectors(site, beamOptions = {}) {
    if (!site) { console.debug('drawSingleSectors: no site'); return; }
    if (!site.azimuths || !Array.isArray(site.azimuths)) {
      console.debug('drawSingleSectors: site.azimuths missing or not array', site);
      return;
    }

    //console.groupCollapsed(`drawSingleSectors: site ${site.siteId}`);
    const layers = [];
    const beamCounts = parseBeamCounts(site.beams, site.azimuths.length);

    const defaultBeamOpts = { color: null, weight: 3, lengthMultiplier: 1.4 };
    const opts = Object.assign({}, defaultBeamOpts, beamOptions);

    site.azimuths.forEach((azRaw, idx) => {
      // coerce az to number (fixes "120" string issues)
      const az = Number(azRaw);
      const color = opts.color || getColor(site, idx);
      //console.groupCollapsed(` sector idx=${idx} rawAz=${azRaw} coercedAz=${az} color=${color}`);
      if (!color) { console.debug('  no color, skipping sector'); console.groupEnd(); return; }
      if (!isFinite(az)) { console.debug('  az is not numeric -> skipping', azRaw); console.groupEnd(); return; }

      const beamsForSector = Number(beamCounts[idx] || 0);
      //console.debug('  beamsForSector:', beamsForSector);

      // draw beam arrows first so sectors are above them
      if (beamsForSector > 1) {
        if (az === 360) {
          // full-circle: irrelevant

        } else {
          const beamAngles = generateBeamAngles(az, beamsForSector, sectorHalfAngle);
          //console.debug('   beamAngles:', beamAngles);
          beamAngles.forEach((beamAz, bi) => {
            //console.debug(`   draw beam ${bi} az=${beamAz}`);
            const arrowLayer = drawBeamArrow(site, beamAz, range * opts.lengthMultiplier, { color, weight: opts.weight });            
            if (arrowLayer) {              
              sectorLayer.addLayer(arrowLayer);
              layers.push(arrowLayer);
            }            
          });
        }
      } else {
        //console.debug('   no beams for this sector');
      }


const outerOutlineColor = '#fff';
const innerOutlineColor = '#000';
const outerWeight = (opts && opts.weight ? opts.weight : 3) + 4;
const innerWeight = (opts && opts.weight ? opts.weight : 3) + 2;

if (az === 360) {
  // full circle: outer white, inner black, then filled circle
  const circOuter = L.circle([site.lat, site.lon], {
    radius: range,
    color: outerOutlineColor,
    fillOpacity: 0,
    weight: outerWeight,
    opacity: 1
  });
  sectorLayer.addLayer(circOuter);

  const circInner = L.circle([site.lat, site.lon], {
    radius: range,
    color: innerOutlineColor,
    fillOpacity: 0,
    weight: innerWeight,
    opacity: 1
  });
  sectorLayer.addLayer(circInner)

  const circFill = L.circle([site.lat, site.lon], {
    radius: range,
    color: color,
    fillColor: color,
    fillOpacity: 0.4,
    weight: 0
  });
  sectorLayer.addLayer(circFill);

  layers.push(circOuter, circInner, circFill);
  //console.debug('   drew full circle with double outline', circFill);
} else {
  // ensure left/right are defined in this scope
  const left  = getAzimuthEnd(site.lat, site.lon, az - sectorHalfAngle, range);
  const right = getAzimuthEnd(site.lat, site.lon, az + sectorHalfAngle, range);

  // outer white outline
  const polyOuter = L.polygon([[site.lat, site.lon], left, right], {
    color: outerOutlineColor,
    fillOpacity: 0,
    weight: outerWeight,
    opacity: 1
  });
  sectorLayer.addLayer(polyOuter);

  // inner black outline
  const polyInner = L.polygon([[site.lat, site.lon], left, right], {
    color: innerOutlineColor,
    fillOpacity: 0,
    weight: innerWeight,
    opacity: 1
  });
  sectorLayer.addLayer(polyInner);

  // filled sector on top (no stroke)
  const polyFill = L.polygon([[site.lat, site.lon], left, right], {
    color: color,
    fillColor: color,
    fillOpacity: 1,
    weight: 0
  });
  sectorLayer.addLayer(polyFill);

  layers.push(polyOuter, polyInner, polyFill);
  //console.debug('   drew polygon with double outline', polyFill);
}


      //console.groupEnd(); // sector
    });

    if (layers.length) {
      sectorLayers[site.siteId] = layers;
      //console.debug(' total layers saved for site:', layers.length);
    } else {
      //console.debug(' no layers for site');
    }
    //console.groupEnd(); // site
  }

  /* unchanged but safer parse & helpers with debug */

  /**
   * Robust parser: accepts
   *  - semicolon string "2;1;3"
   *  - array of numbers [2,1,3]
   *  - array of objects [{count:2},{beams:1},{value:3}]
   * Pads/trims to expectedLength, missing => 0
   */
  function parseBeamCounts(siteBeams, expectedLength) {
    const result = new Array(expectedLength).fill(0);

    // string case: "2;1;3"
    if (siteBeams && typeof siteBeams === 'string') {
      const parts = siteBeams.split(';').map(s => {
        const n = parseInt(s, 10);
        return isNaN(n) ? 0 : n;
      });
      for (let i = 0; i < expectedLength; i++) result[i] = parts[i] || 0;
      console.debug('parseBeamCounts (string) ->', result);
      return result;
    }

    // array case
    if (Array.isArray(siteBeams)) {
      for (let i = 0; i < expectedLength; i++) {
        const v = siteBeams[i];
        if (v === undefined || v === null) { result[i] = 0; continue; }

        // number directly
        if (typeof v === 'number' && isFinite(v)) { result[i] = Math.max(0, Math.floor(v)); continue; }

        // string inside array
        if (typeof v === 'string') {
          const n = parseInt(v, 10);
          result[i] = isNaN(n) ? 0 : n;
          continue;
        }

        // object: try common numeric property names
        if (typeof v === 'object') {
          const keysToTry = ['count','beams','value','cnt','num','n'];
          let found = false;
          for (let k of keysToTry) {
            if (Object.prototype.hasOwnProperty.call(v, k)) {
              const n = parseInt(v[k], 10);
              if (!isNaN(n)) { result[i] = Math.max(0, Math.floor(n)); found = true; break; }
            }
          }
          // if not found but object is a plain number-like (rare), try coercion
          if (!found) {
            const coerced = Number(v);
            result[i] = (isFinite(coerced) && coerced !== 0) ? Math.max(0, Math.floor(coerced)) : 0;
          }
          continue;
        }

        // fallback
        result[i] = 0;
      }

      //console.debug('parseBeamCounts (array) ->', result);
      return result;
    }

    // fallback: not provided or unexpected type
    //console.debug('parseBeamCounts: invalid input -> default zeros', siteBeams);
    return result;
  }


  function generateBeamAngles(az, count, halfAngle) {
    az = Number(az);
    if (!count || count <= 0) return [];
    if (count === 1) return [normalizeAz(az)];

    const centerOffset = (count - 1) / 2;
    const step = halfAngle / centerOffset;
    const angles = [];
    for (let i = 0; i < count; i++) {
      const offsetMultiplier = i - centerOffset;
      const beamAz = az + offsetMultiplier * step;
      angles.push(normalizeAz(beamAz));
    }
    return angles;
  }

  function normalizeAz(a) {
    let x = Number(a) % 360;
    if (isNaN(x)) return 0;
    if (x < 0) x += 360;
    return x;
  }

  function drawBeamArrow(site, angle, lengthMeters, opts = {}) {
    if (!site || typeof angle !== 'number') { console.debug('drawBeamArrow: invalid input', site, angle); return null; }

    // visual params (unchanged)
    const weight = (typeof opts.weight === 'number') ? opts.weight : 3; // visible stroke for arrow body
    const outerOutlineColor = '#ffffff'; // outer outline (white)
    const innerOutlineColor = '#000000'; // inner outline (black)
    const arrowColor = '#ffffff';        // arrow fill/body (white)

    // tip sizing in meters (same base logic as before)
    const tipLenMeters = Math.max(5, lengthMeters * 0.06);
    const tipBaseHalfWidthMeters = Math.max(2, tipLenMeters * 0.5);

    // shaft length in meters (same as before)
    const shaftLen = Math.max(1, lengthMeters - tipLenMeters);

    // compute shaft end using meters (unchanged)
    const shaftEnd = getAzimuthEnd(site.lat, site.lon, angle, shaftLen);

    // validate shaftEnd
    if (!isFinite(shaftEnd[0]) || !isFinite(shaftEnd[1])) {
      console.debug('drawBeamArrow: invalid shaftEnd', shaftEnd);
      return null;
    }

    // --- SHAFT: outer white, middle black, body white (unchanged) ---
    const outerWeight = Math.max(1, weight + 6);
    const middleWeight = Math.max(1, weight + 3);
    const bodyWeight = Math.max(1, weight);

    // create polylines (do NOT add them directly to map here)
    const outerShaft = L.polyline([[site.lat, site.lon], shaftEnd], {
      color: outerOutlineColor, weight: outerWeight, opacity: 1
    });
    const middleShaft = L.polyline([[site.lat, site.lon], shaftEnd], {
      color: innerOutlineColor, weight: middleWeight, opacity: 1
    });
    const bodyShaft = L.polyline([[site.lat, site.lon], shaftEnd], {
      color: arrowColor, weight: bodyWeight, opacity: 1
    });

    // group them, add the group to the map and return the group so callers can manage it
    const arrowGroup = L.layerGroup([outerShaft, middleShaft, bodyShaft]);
    return arrowGroup;

  }




    // ▶ clear + (re)draw every site in currentSites
	function drawAllSectorsTimed() {
	  if(!bgRunning)    {clearSectors();}
	  
    currentSites.forEach(site => {
		if (toggleSectors.checked) {
		  drawSingleSectors(site);
		}
		drawSingleSite(site);
	  });
	}

	function drawAllSectors() {
	  const t0 = performance.now();
    if (!toggleAlwaysShow.checked) { clearSectors(); return; }
	  drawAllSectorsTimed();
	  const dt = Math.round(performance.now() - t0);

	  // badge.textContent = dt + ' ms';
	  // // color logic:
	  // if (dt < 150)       badge.style.background = 'rgba(0,128,0,0.7)';   // green
	  // else if (dt < 500) badge.style.background = 'rgba(255,165,0,0.7)'; // yellow/orange
	  // else                badge.style.background = 'rgba(255,0,0,0.7)';   // red
	}



  // 1) getAzimuthEnd
  function getAzimuthEnd(lat, lng, az, len) {
    var R = 6378137;
    var rad = Math.PI / 180;
    var brng = az * rad;
    var lat1 = lat * rad;
    var lon1 = lng * rad;
    var lat2 = Math.asin(
      Math.sin(lat1) * Math.cos(len / R) +
      Math.cos(lat1) * Math.sin(len / R) * Math.cos(brng)
    );
    var lon2 = lon1 + Math.atan2(
      Math.sin(brng) * Math.sin(len / R) * Math.cos(lat1),
      Math.cos(len / R) - Math.sin(lat1) * Math.sin(lat2)
    );
    return [lat2 / rad, lon2 / rad];
  }

  // 2) getColor
  function getColor(site, idx) {
    var theme = currentTheme;
    if (theme === '1') {
      return ['#003366','#990000','#CC9900'][idx % 3];
    }
    if (theme === '2') {
      if (!siteColors[site.siteId]) {
        siteColors[site.siteId] = '#' +
          Math.floor(Math.random() * 16777215)
            .toString(16)
            .padStart(6, '0');
      }
      return siteColors[site.siteId];
    }
    if (theme === '3') {
      return 'green';
    }
    // theme '4'
    return null;
  }

  // store finished measurements so they can be cleared
  var finishedMeasureMarkers = [];
  var finishedMeasureLines   = [];

  // bearing helper (ES5)
  function getBearing(lat1, lon1, lat2, lon2) {
    var toRad = Math.PI / 180;
    var toDeg = 180 / Math.PI;
    var φ1 = lat1 * toRad;
    var φ2 = lat2 * toRad;
    var Δλ = (lon2 - lon1) * toRad;
    var y = Math.sin(Δλ) * Math.cos(φ2);
    var x = Math.cos(φ1) * Math.sin(φ2) -
            Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
    var θ = Math.atan2(y, x);
    var brng = (θ * toDeg + 360) % 360;
    return brng;
  }

  // clear only the "current" measuring (not finished ones)
  function clearCurrentMeasurement() {
    if (measureLine) {
      map.removeLayer(measureLine);
      measureLine = null;
    }
    if (measureMarker) {
      map.removeLayer(measureMarker);
      measureMarker = null;
    }
    refPoint = null;
  }

  // clear ALL measurements (finished + current)
  function clearAllMeasurements() {
    // remove finished
    for (var i = 0; i < finishedMeasureLines.length; i++) {
      map.removeLayer(finishedMeasureLines[i]);
    }
    for (var j = 0; j < finishedMeasureMarkers.length; j++) {
      map.removeLayer(finishedMeasureMarkers[j]);
    }
    finishedMeasureLines = [];
    finishedMeasureMarkers = [];

    // remove current
    clearCurrentMeasurement();
  }

  // start / finish measurement on click
  // function startMeasure(e) {
  //   // if no start point -> start new measurement
  //   if (!refPoint) {
  //     refPoint = e.latlng;
  //     measureMarker = L.marker(refPoint).addTo(map);
  //     // ensure mousemove live updates are active (they will be if toggle enabled)
  //     // measureLine will be created/updated in updateMeasure
  //   } else {
  //     // finish measurement to clicked point
  //     var end = e.latlng;

  //     // remove any transient line (we will create a final one)
  //     if (measureLine) {
  //       map.removeLayer(measureLine);
  //       measureLine = null;
  //     }

  //     // create final polyline and final marker
  //     var finalLine = L.polyline([refPoint, end]).addTo(map);
  //     var d = refPoint.distanceTo(end);
  //     var az = getBearing(refPoint.lat, refPoint.lng, end.lat, end.lng);
  //     finalLine.bindTooltip(d.toFixed(1) + ' m · ' + az.toFixed(1) + '°', { permanent: true, offset: [0, -10] }).openTooltip();

  //     var endMarker = L.marker(end).addTo(map);

  //     // store finished measurement for later clearing
  //     finishedMeasureLines.push(finalLine);
  //     finishedMeasureMarkers.push(endMarker);

  //     // remove the start marker (optional) or keep it: here we'll remove it
  //     if (measureMarker) {
  //       map.removeLayer(measureMarker);
  //       measureMarker = null;
  //     }

  //     // reset for next measurement
  //     refPoint = null;
  //     measureLine = null;
  //   }
  // }



  // pixel-based arrow. sizePx = tip-to-base box in pixels. color follows line.
  function makeArrow(latlng, angleDeg, sizePx, color) {
    sizePx = sizePx || 18;           // slightly bigger by default
    color = color || '#000';
    const half = sizePx / 2;
    // triangle points: tip centered at top, base along bottom
    const svg =
      `<svg xmlns="http://www.w3.org/2000/svg" width="${sizePx}" height="${sizePx}" viewBox="0 0 ${sizePx} ${sizePx}" aria-hidden="true">
        <polygon points="${half},0 ${sizePx},${sizePx} 0,${sizePx}" fill="${color}" stroke="${color}" stroke-width="1"/>
      </svg>`;
    const html = `<div style="width:${sizePx}px;height:${sizePx}px;display:inline-block;transform:rotate(${angleDeg}deg);">${svg}</div>`;
    const icon = L.divIcon({
      className: 'arrow-icon',
      html: html,
      iconSize: [sizePx, sizePx],
      iconAnchor: [half, half] // center the icon on the latlng
    });
    return L.marker(latlng, { icon: icon, interactive: false }).addTo(map);
  }


  function startMeasure(e) {
    // if no start point -> start new measurement
    if (!refPoint) {
      refPoint = e.latlng;

      // replace marker with small arrow tip (temporary start marker)
      //measureMarker = makeArrow(refPoint, 0, 18, /*color*/ measureLine && measureLine.options && measureLine.options.color || '#000');


      // ensure mousemove live updates are active (they will be if toggle enabled)
      // measureLine will be created/updated in updateMeasure
    } else {
      // finish measurement to clicked point
      var end = e.latlng;

      // remove any transient line (we will create a final one)
      if (measureLine) {
        map.removeLayer(measureLine);
        measureLine = null;
      }

      // create final polyline and final arrow (instead of marker)
      var finalLine = L.polyline([refPoint, end]).addTo(map);
      var d = refPoint.distanceTo(end);
      var az = getBearing(refPoint.lat, refPoint.lng, end.lat, end.lng);
      finalLine.bindTooltip(d.toFixed(1) + ' m · ' + az.toFixed(1) + '°', { permanent: true, offset: [0, -10] }).openTooltip();

      // create small arrow at the end, oriented along bearing
      var lineColor = finalLine.options && finalLine.options.color || '#000';
      var endArrow = makeArrow(end, az, 18, lineColor);

      // store finished measurement for later clearing
      finishedMeasureLines.push(finalLine);
      finishedMeasureMarkers.push(endArrow);

      // remove the start arrow
      if (measureMarker) {
        map.removeLayer(measureMarker);
        measureMarker = null;
      }

      // reset for next measurement
      refPoint = null;
      measureLine = null;
    }
  }


  // live update while moving mouse after a start click
  function updateMeasure(e) {
    if (!refPoint) return;

    // update transient line
    if (measureLine) {
      map.removeLayer(measureLine);
      measureLine = null;
    }

    measureLine = L.polyline([refPoint, e.latlng]).addTo(map);

    // compute metrics
    var d = refPoint.distanceTo(e.latlng);
    var az = getBearing(refPoint.lat, refPoint.lng, e.latlng.lat, e.latlng.lng);

    // transient tooltip (non-permanent while dragging)
    measureLine.bindTooltip(d.toFixed(1) + ' m · ' + az.toFixed(1) + '°', { permanent: false, offset: [0, -10] }).openTooltip();
  }

  // wire/unwire listeners when toggle changes
  measureToggle.onchange = function(e) {
    measureMode = e.target.checked;
    // when enabling, clear all previous measurements per your request
    if (measureMode) {
      clearAllMeasurements();
      map.on('click', startMeasure);
      map.on('mousemove', updateMeasure);
    } else {
      map.off('click', startMeasure);
      map.off('mousemove', updateMeasure);
      // optionally clear any transient measurement
      clearCurrentMeasurement();
    }
  };




  // 3) clearMeasure
  function clearMeasure() {
    if (measureLine) {
      map.removeLayer(measureLine);
    }
    if (measureMarker) {
      map.removeLayer(measureMarker);
    }
    refPoint = null;
    measureLine = null;
    measureMarker = null;
  }

  // 4) startMeasure
  // function startMeasure(e) {
  //   if (!refPoint) {
  //     refPoint = e.latlng;
  //     measureMarker = L.marker(refPoint).addTo(map);
  //   } else {
  //     map.off('mousemove', updateMeasure);
  //   }
  // }



  // 5) updateMeasure
  // function updateMeasure(e) {
  //   if (!refPoint) return;
  //   if (measureLine) {
  //     map.removeLayer(measureLine);
  //   }
  //   measureLine = L.polyline([refPoint, e.latlng]).addTo(map);
  //   var d = refPoint.distanceTo(e.latlng).toFixed(1);
  //   measureLine.bindTooltip(d + ' m', { permanent: true, offset: [0, -10] }).openTooltip();
  // }




  // 6) parseCoord
  function parseCoord(input) {
    var nums = input.match(/-?\\d+\\.?\\d*/g);
    if (!nums || nums.length < 2) return null;
    var a = parseFloat(nums[0]);
    var b = parseFloat(nums[1]);
    var lat = a, lon = b;
    if (Math.abs(a) > 90 && Math.abs(b) <= 90) {
      lat = b; lon = a;
    }
    return [lat, lon];
  }

  // 7) inAsean
  function inAsean(lat, lon) {
    return lat >= -11 && lat <= 29 && lon >= 92 && lon <= 141;
  }

  // 8) bindFeature
  function bindFeature(layer) {
    layer.on('contextmenu', function(e) {
      e.originalEvent.preventDefault();
      showContext(e, true);
    });
  }

  // 9) showContext
// --- showContext: centralized context menu for map & features ---
function showContext(e, isFeature) {
  contextMenu.style.display = 'none';
  contextMenu.innerHTML = '';

  // helpers
  function writeToClipboard(text) {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      return navigator.clipboard.writeText(text).catch(function () {
        if (typeof fallbackCopyText === 'function') return fallbackCopyText(text);
        window.prompt('Copy this text (Ctrl/Cmd+C then Enter):', text);
      });
    } else {
      if (typeof fallbackCopyText === 'function') return fallbackCopyText(text);
      window.prompt('Copy this text (Ctrl/Cmd+C then Enter):', text);
    }
  }

  // Copy LatLon
  var copyLatLon = document.createElement('div');
  copyLatLon.textContent = 'Copy LatLon';
  copyLatLon.onclick = function () {
    var text = e.latlng.lat.toFixed(5) + '\t' + e.latlng.lng.toFixed(5);
    writeToClipboard(text);
    contextMenu.style.display = 'none';
  };
  contextMenu.appendChild(copyLatLon);

  // Copy LonLat
  var copyLonLat = document.createElement('div');
  copyLonLat.textContent = 'Copy LonLat';
  copyLonLat.onclick = function () {
    var text = e.latlng.lng.toFixed(5) + '\t' + e.latlng.lat.toFixed(5);
    writeToClipboard(text);
    contextMenu.style.display = 'none';
  };
  contextMenu.appendChild(copyLonLat);


  // --- add: context checkbox for Always show / Show all (reuse toggleAlwaysShow) ---
  var alwaysDiv = document.createElement('div');
  alwaysDiv.style.display = 'flex';
  alwaysDiv.style.alignItems = 'center';
  var aChk = document.createElement('input');
  aChk.type = 'checkbox';
  aChk.id = 'ctxAlwaysChk';
  aChk.checked = !!toggleAlwaysShow.checked;
  aChk.style.marginRight = '8px';
  aChk.onchange = function () {
    toggleAlwaysShow.checked = aChk.checked;
    // reuse existing logic for toggleAlwaysShow
    toggleAlwaysShow.dispatchEvent(new Event('change'));
  };
  var aLabel = document.createElement('label');
  aLabel.htmlFor = 'ctxAlwaysChk';
  aLabel.textContent = ' Show Sites';
  alwaysDiv.appendChild(aChk);
  alwaysDiv.appendChild(aLabel);
  contextMenu.appendChild(alwaysDiv);



  // --- add: context checkbox for Show sectors (reuse toggleSectors) ---
  var sectorsDiv = document.createElement('div');
  sectorsDiv.style.display = 'flex';
  sectorsDiv.style.alignItems = 'center';
  var sChk = document.createElement('input');
  sChk.type = 'checkbox';
  sChk.id = 'ctxSectorsChk';
  sChk.checked = !!toggleSectors.checked;
  sChk.style.marginRight = '8px';
  sChk.onchange = function () {
    toggleSectors.checked = sChk.checked;
    // reuse existing logic
    toggleSectors.dispatchEvent(new Event('change'));
  };
  var sLabel = document.createElement('label');
  sLabel.htmlFor = 'ctxSectorsChk';
  sLabel.textContent = ' Sectors';
  sectorsDiv.appendChild(sChk);
  sectorsDiv.appendChild(sLabel);
  contextMenu.appendChild(sectorsDiv);

  // Measure distance (checkbox) — toggle the panel checkbox so existing logic is reused
  var measureDiv = document.createElement('div');
  measureDiv.style.display = 'flex';
  measureDiv.style.alignItems = 'center';
  var chk = document.createElement('input');
  chk.type = 'checkbox';
  chk.id = 'ctxMeasureChk';
  chk.checked = !!measureToggle.checked;
  chk.style.marginRight = '8px';
  chk.onchange = function () {
    measureToggle.checked = chk.checked;
    // trigger the existing change handler (dispatch event)
    measureToggle.dispatchEvent(new Event('change'));
  };
  var label = document.createElement('label');
  label.htmlFor = 'ctxMeasureChk';
  label.textContent = ' Measure distance';
  measureDiv.appendChild(chk);
  measureDiv.appendChild(label);
  contextMenu.appendChild(measureDiv);


  // Clear measurement
  var clearDiv = document.createElement('div');
  clearDiv.textContent = 'Clear measurement';
  clearDiv.onclick = function () {
    if (typeof clearAllMeasurements === 'function') clearAllMeasurements();
    contextMenu.style.display = 'none';
  };
  contextMenu.appendChild(clearDiv);



  // Add point input (use existing gotoBtn logic by setting gotoInput and triggering its click)
  var addWrap = document.createElement('div');
  addWrap.style.display = 'flex';
  addWrap.style.gap = '6px';
  var ctxAdd = document.createElement('input');
  ctxAdd.type = 'text';
  ctxAdd.placeholder = 'lon,lat or lat,lon';
  ctxAdd.style.flex = '1';
  var ctxAddBtn = document.createElement('button');
  ctxAddBtn.textContent = 'Add';
  ctxAddBtn.onclick = function () {
    var v = (ctxAdd.value || '').trim();
    if (!v) return;
    gotoInput.value = v;
    try { gotoBtn.click(); } catch (err) { if (typeof gotoBtn.onclick === 'function') gotoBtn.onclick(); }
    contextMenu.style.display = 'none';
  };
  ctxAdd.addEventListener('keydown', function(evt){
    if (evt.key === 'Enter') ctxAddBtn.click();
  });
  addWrap.appendChild(ctxAdd);
  addWrap.appendChild(ctxAddBtn);
  contextMenu.appendChild(addWrap);


  // Search input (jump to first match)
  var searchWrap = document.createElement('div');
  searchWrap.style.display = 'flex';
  searchWrap.style.gap = '6px';
  var ctxSearch = document.createElement('input');
  ctxSearch.type = 'text';
  ctxSearch.placeholder = 'Search siteid or name';
  ctxSearch.style.flex = '1';
  var ctxSearchBtn = document.createElement('button');
  ctxSearchBtn.textContent = 'OK';
  ctxSearchBtn.onclick = function () {
    var term = (ctxSearch.value || '').trim().toLowerCase();
    if (!term) return;
    // query DB and go to first result
    db.sites.filter(function (s) {
      return s.siteId.toLowerCase().indexOf(term) !== -1 ||
             s.sitename.toLowerCase().indexOf(term) !== -1;
    }).toArray().then(function (matches) {
      if (matches && matches.length > 0) {
        var site = matches[0];
        map.setView([site.lat, site.lon], +zoomSlider.value);
        site.azimuths = (String(site.azRaw || '')).split(';').map(Number).filter(function(n){return !isNaN(n);});
        currentSites = [site];
        drawAllSectors();
      } else {
        // optional: small visual feedback
        ctxSearch.style.borderColor = 'red';
        setTimeout(()=> ctxSearch.style.borderColor = '', 800);
      }
      contextMenu.style.display = 'none';
    }).catch(function(){
      contextMenu.style.display = 'none';
    });
  };
  
/* ----------  Insert after ctxSearchBtn.onclick block ---------- */

/* Reusable function: go to siteId (ES5) */
function gotoSiteById(siteId) {
  if (!siteId) return;
  // normalize
  var term = String(siteId).trim().toLowerCase();

  // Query local DB and go to first match (same behavior as your context search)
  db.sites.filter(function (s) {
    return (s.siteId || '').toLowerCase().indexOf(term) !== -1 ||
           (s.sitename || '').toLowerCase().indexOf(term) !== -1;
  }).toArray().then(function (matches) {
    if (matches && matches.length > 0) {
      var site = matches[0];
      map.setView([site.lat, site.lon], +zoomSlider.value);
      site.azimuths = (String(site.azRaw || '')).split(';')
                       .map(function(n){ return parseFloat(n); })
                       .filter(function(n){ return !isNaN(n); });
      currentSites = [site];
      drawAllSectors();
    } else {
      // optional: small visual feedback if not found
      console.warn('gotoSiteById: not found', siteId);
    }
  }).catch(function(err){
    console.error('gotoSiteById error', err);
  });
}



/* Optional: notify parent that iframe is ready (useful so parent waits before sending) */
function notifyParentReady() {
  try {
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({ type: 'btsmapReady' }, '*'); // replace '*' with parent origin if known
    }
  } catch (e) {}
}
document.addEventListener('DOMContentLoaded', function(){ notifyParentReady(); });




/* Query param fallback: if loaded with ?siteid=XXX call gotoSiteById */
(function () {
  function getParam(name) {
    var m = location.search.match(new RegExp('[?&]' + name + '=([^&]*)'));
    return m ? decodeURIComponent(m[1].replace(/\+/g, ' ')) : null;
  }
  var q = getParam('siteid');
  if (q) {
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      gotoSiteById(q);
    } else {
      document.addEventListener('DOMContentLoaded', function () { gotoSiteById(q); });
    }
  }
})();


  
  ctxSearch.addEventListener('keydown', function(evt){
    if (evt.key === 'Enter') ctxSearchBtn.click();
  });
  searchWrap.appendChild(ctxSearch);
  searchWrap.appendChild(ctxSearchBtn);
  contextMenu.appendChild(searchWrap);


  // optional feature-specific item
  if (isFeature) {
    var infoDiv = document.createElement('div');
    infoDiv.textContent = 'Show info';
    infoDiv.onclick = function () {
      contextMenu.style.display = 'none';
      infoPopup.style.display = 'block';
    };
    contextMenu.appendChild(infoDiv);

    // NEW: Change label menu item (id used by per-marker handler)
    var changeDiv = document.createElement('div');
    changeDiv.id = 'changeLabel';
    changeDiv.textContent = 'Change label';
    // optional: give minimal built-in action as fallback (per-marker handler will override this onclick)
    changeDiv.onclick = function () {
      contextMenu.style.display = 'none';
    };
    contextMenu.appendChild(changeDiv);
  }


  // position & show
  contextMenu.style.top = e.containerPoint.y + 'px';
  contextMenu.style.left = e.containerPoint.x + 'px';
  contextMenu.style.display = 'block';
}

//sampai sini

    map.on('contextmenu',e=>{ e.originalEvent.preventDefault(); showContext(e,false); });
    map.off('mousemove'); 
    //map.on('mousemove',e=>{ coordDisplay.textContent = `${e.latlng.lat.toFixed(5)} ${e.latlng.lng.toFixed(5)}`; });
    let elevTimer;
    map.on('mousemove', function (e) {
      var lat = e.latlng.lat.toFixed(5),
          lon = e.latlng.lng.toFixed(5);

      clearTimeout(elevTimer);
      elevTimer = setTimeout(function () {
        // pick the correct endpoint
        var url;
        if (!isGAS) {
          //url = 'http://localhost:3000/elevation?lat=' + lat + '&lon=' + lon;
        } else {
          coordDisplay.textContent = `${e.latlng.lat.toFixed(5)} ${e.latlng.lng.toFixed(5)}`;
          return;
        }

        fetch(url)
          .then(function (res) { return res.json(); })
          .then(function (data) {
            var elev = (data.results && data.results[0] && data.results[0].elevation) || 'N/A';
            coordDisplay.textContent = lat + ' ' + lon + ' ' + elev + ' m';
          })
          .catch(function () {
            coordDisplay.textContent = lat + ' ' + lon;
          });
      }, 200);
    });

    map.on('click',()=>{ contextMenu.style.display='none'; }); document.addEventListener('keydown',e=>{ if(e.key==='Escape'){ contextMenu.style.display='none'; infoPopup.style.display='none'; }});
    infoClose.onclick = ()=>{ infoPopup.style.display='none'; };

    zoomSlider.oninput = e=>{ map.setZoom(+e.target.value); };
    map.on('zoomend', ()=>{ zoomSlider.value = map.getZoom(); });
    //rangeSlider.oninput = e=>{ range = +e.target.value; drawSectors(); };
    rangeSlider.oninput = e => {
      range = +e.target.value;
      drawAllSectors();   // ← new: redraw with updated range
    };

    themeSelect.onchange = e=>{ currentTheme = e.target.value; if(currentTheme!=='2') Object.keys(siteColors).forEach(k=>delete siteColors[k]); drawAllSectors(); };

    // measureToggle.onchange = e=>{ measureMode = e.target.checked; clearMeasure(); if(measureMode){ map.on('click',startMeasure); map.on('mousemove',updateMeasure); } else { map.off('click',startMeasure); map.off('mousemove',updateMeasure); } };

    searchInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();      // stop any form-submit or default behavior
        searchBtn.click();       // trigger your existing handler
      }
    });

    gotoInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();      // stop any form-submit or default behavior
        gotoBtn.click();       // trigger your existing handler
      }
    });

    gotoInput.addEventListener('paste', function(e) {
      e.preventDefault();
      const text = (e.clipboardData || window.clipboardData).getData('text');

      // 1. Tokenize on any non-[0-9 . -] chars
      const toks = text.split(/[^0-9.\-]+/);
      //console.log(toks);
      // 2. Keep only signed decimal-point tokens
      const decs = toks.filter(t => /^-?\d+\.\d+$/.test(t));
      //console.log(decs);
      // 3. Group into [long, lat] or [lat, long] pairs
      const pairs = [];
      for (let i = 0; i + 1 < decs.length; i += 2) {
        pairs.push(`${decs[i]} ${decs[i + 1]}`);
      }
      // console.log(pairs);
      
      // 4. Deduplicate, preserving first-seen order
      const seen = new Set();
      const unique = [];
      for (const p of pairs) {
        if (!seen.has(p)) {
          seen.add(p);
          unique.push(p);
        }
      }
      // console.log(unique);
      // 5. Output all unique pairs      
      this.value = this.value + ' ' + unique.join(' ');
    });


		gotoBtn.onclick = function(){
			var nums = (gotoInput.value.match(/-?\d+\.?\d*/g) || []).map(Number);
			var newMarkers = [];

			for (var i = 0; i + 1 < nums.length; i += 2) {
				var a = nums[i], b = nums[i+1];
				var lat = Math.abs(a) <= 90 && Math.abs(b) > 90 ? a : b;
				var lon = lat === a ? b : a;
				if (!inAsean(lat, lon)) continue;

				var idx    = pointMarkers.length + 1;
				var size   = Math.round(currentTextSize * 1.5); // 1.8× font-size
				var html =
				'<span style="font-size:' + size + 'px;'
				+ '-webkit-text-stroke:1px white;'
				+ 'text-stroke:3px black;'
				+ 'color:red;'
				+ 'text-shadow:-1px -1px 0 #000,1px -1px 0 #000,'
				+           '-1px 1px 0 #000,1px 1px 0 #000;">'
				+   '<span class="blinking">★</span>'
				+   idx
				+ '</span>';

				// apply no-bg to strip out white box
				var marker = L.marker([lat, lon], {
				icon: L.divIcon({
					className: 'no-bg',
					html:      html,
					iconAnchor: [0, 0]
				})
				}).addTo(map);

				pointMarkers.push(marker);
				newMarkers.push(marker);


				if (newMarkers.length === 0) return;

				if (newMarkers.length === 1) {
				map.flyTo(
					newMarkers[0].getLatLng(),
					map.getMaxZoom(),
					{ animate: true, duration: 2 }
				);
				} else {
				const bounds = L.latLngBounds(newMarkers.map(m => m.getLatLng()));
				map.fitBounds(bounds, { padding: [20, 20], animate: true, duration: 2 });
				}


			(function(m, index, labelSize){
				m.on('contextmenu', function(e) {
          e.originalEvent.preventDefault();

          showContext(e, true);



          // Fallback using a temporary textarea + document.execCommand('copy')
          function fallbackCopyText(text) {
            try {
              const ta = document.createElement('textarea');
              ta.value = text;
              // Avoid page scrolling to bottom on iOS by making textarea small & offscreen
              ta.style.position = 'fixed';
              ta.style.left = '-9999px';
              ta.style.top = '0';
              document.body.appendChild(ta);
              ta.focus();
              ta.select();

              const ok = document.execCommand('copy');
              document.body.removeChild(ta);

              if (!ok) {
                // final fallback: let user manually copy by prompting
                window.prompt('Copy this text (Ctrl/Cmd+C then Enter):', text);
              }
            } catch (e) {
              try { document.body.removeChild(ta); } catch(_) {}
              window.prompt('Copy this text (Ctrl/Cmd+C then Enter):', text);
            }
          }


          // closure holds m, index, labelSize
          document.getElementById('changeLabel').onclick = function() {
          var newLabel = prompt('New label', index);
          if (newLabel) {
            // use labelSize from closure
            var newHtml =
            '<span style="font-size:' + labelSize + 'px;'
            + '-webkit-text-stroke:1px white;'
            + 'text-stroke:1px black;'
            + 'color:lime;'
            + 'text-shadow:-1px -1px 0 #000,1px -1px 0 #000,'
            +           '-1px 1px 0 #000,1px 1px 0 #000;">'
            + '★' + newLabel
            + '</span>';
            m.setIcon(L.divIcon({
            className: 'no-bg',
            html:      newHtml,
            iconAnchor: [0, 0]
            }));
          }
          contextMenu.style.display = 'none';
          };
        });
			})(marker, idx, size);

		}
	};


  (function(){
    const container = document.getElementById('searchResults');
    if (!container) return;

    // helper: get siteid from row (expects attribute data-siteid or .siteid element)
    function getSiteIdFromRow(row) {
      if (!row) return null;
      if (row.dataset && row.dataset.siteid) return row.dataset.siteid;
      const el = row.querySelector('.siteid');
      return el ? el.textContent.trim() : null;
    }

    // delegate mouseenter/mouseleave to add hover class only when not pinned
    container.addEventListener('pointerenter', e => {
      const row = e.target.closest('.result-row');
      if (!row) return;
      if (row.classList.contains('pinned')) return;
      row.classList.add('hovered');
    }, true);

    container.addEventListener('pointerleave', e => {
      const row = e.target.closest('.result-row');
      if (!row) return;
      row.classList.remove('hovered');
    }, true);

    // clear any lingering hovered on scroll
    container.addEventListener('scroll', () => {
      container.querySelectorAll('.result-row.hovered').forEach(r => r.classList.remove('hovered'));
    });

    // click toggles pinned state and dispatches custom event
    container.addEventListener('click', e => {
      const row = e.target.closest('.result-row');
      if (!row) return;
      const siteid = getSiteIdFromRow(row);

      // toggle pinned
      const pinned = row.classList.toggle('pinned');

      // if pinned, ensure hover class removed and stay highlighted
      if (pinned) {
        row.classList.remove('hovered');
        row.scrollIntoView({ block: 'nearest', behavior: 'smooth' });

        // panel -> collapsed & position results
        showSearchResultsAtPanel();
      } else {
        // restore panel when unpinned
        setPanelCollapsed(false);
      }

      // dispatch a clear, uniform event for your existing app code to use
      const ev = new CustomEvent('searchResultSelected', {
        detail: { siteid: siteid, element: row, pinned: pinned }
      });
      window.dispatchEvent(ev);

      // If your app previously had a global function for selection, call it safely
      if (typeof window.onSearchResultClick === 'function') {
        try { window.onSearchResultClick(siteid, row, pinned); } catch(e){ console.warn(e); }
      }
    });
  })();

  </script>
</body>
</html>
