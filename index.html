<!DOCTYPE html>
<html lang="en">

<head>
	<title>QTD3</title>
	  <script>
	    // SVG-only favicon: white "N" on hsl(219 100% 50%) background
	    (function(){
	      const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64" role="img" aria-label="N">
	        <rect width="100%" height="100%" fill="hsl(219 100% 50%)"/>
	        <!-- left vertical bar -->
	        <rect x="8" y="8" width="10" height="48" fill="#fff"/>
	        <!-- diagonal stroke (slanted middle) -->
	        <polygon points="18,8 30,8 46,56 34,56" fill="#fff"/>
	        <!-- right vertical bar -->
	        <rect x="46" y="8" width="10" height="48" fill="#fff"/>
	      </svg>`; 
	
	      const urlx = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
	      document.querySelectorAll('link[rel~="icon"]').forEach(n => n.remove());
	      const link = document.createElement('link');
	      link.rel = 'icon';
	      link.type = 'image/svg+xml';
	      link.href = urlx;
	      document.head.appendChild(link);
	    })();
	  </script>
	
    <script>
        // This line declares a variable called "url" and assigns it a value of "Api_Endpoint_Url"
        // deployment remarks: 1.25 custom emailcc Kal and CJ
        //let url = "https://script.google.com/macros/s/AKfycbwyS3ETZFJf2hMZhi7LhmhQ4etDvgEOjgeIy_RvAH71q6Ub1YI8i7nzX5lIbeAdPs3c0g/exec";
        // deployment remarks: 1.26 add mailing list CJ Kalimantan
        //let url = "https://script.google.com/macros/s/AKfycbz-ZYHuUXE0_bz4ifwpsTZUk7pp3lfGZItL5D4oYhujSSX7TdFFtkyR8jNoaTNXN8x_eQ/exec";
        // deployment remarks: 1.27 add mailing list SS
        //let url = "https://script.google.com/macros/s/AKfycbz_he-H_wSOYyP0a_qv_PNc2XOPvN0MCrPZIxh0YlfnhmZUlzz0mmoCb_t4ah1sehnJ0w/exec";
		// deployment remarks: 1.28 efficient search
        //let url = "https://script.google.com/macros/s/AKfycbw15mK5uxYETdRb3iKUUULz_VDXtJCmCUvEdX36KYH5f69WIotk6ZVx039kmxXz9KY1OQ/exec";
		//let url = "https://script.google.com/macros/s/AKfycbxUbORlCPRCtAxec2UAyusvSJ3mWyiu-HmFHOP2oToVGy4lyy-lvePBecvUxM5Frcwz-A/exec";
		// deployment remarks: 3.1 new script
		// let url ="https://script.google.com/macros/s/AKfycbzHQ6Xe2ZlWkkxFYBos3YgrDClm7tBlvjCRyc6EqkiZ26uV2FTviiILofNtu7CxZUZN/exec";
		//let url ="https://script.google.com/macros/s/AKfycbyReu2avCWcEQLkZbgCtS6KR3q_ebP96fbIDaMWLZCZV_iddxmj7nx-zbxzQOdTLVhc/exec";
		let url="https://script.google.com/macros/s/AKfycbx9XIxZUWkN85duC7IB-2HnX3khkbQ-1H1_y0x-GHKDBC6sQUPI85sdm43967IzeDlJ/exec";
		
		let lastqtdaz = url;
		
        let folder_sumatra = '18OLcLDIpnI7ErgJHgaS1DztCSXqt2L0b';
        let folder_java = '1abv_c9lvKfOh_dE6GQAXHXqKj6GAOzUz';
        let folder_kalimantan = '1lP84IOUvlY1VaxiYZM6S_3-HuUx-NHZW';
        let folder_all = '1CvPDze6Ye7gjrNnHxtY2ScZiwSsrZsGy';
        let startTime = performance.now();
        let return_url = "done;21SPT0169_240405_mt3.jpeg;https://drive.google.com/thumbnail?id=1QZhvAUKfURfq9Oe8HHahr_MaeqjpsEpe&sz=w1000;21SPT0169_240405_et3.jpeg;https://drive.google.com/thumbnail?id=16naMjJRtZW0Sgarplb305GLEhZEjawEv&sz=w1000;21SPT0169_240405_az3v.jpeg;https://drive.google.com/thumbnail?id=1umW6CZlqa3iQ2PdJNVGIw-qnPkcpqgzp&sz=w1000;21SPT0169_240405_az3.jpeg;https://drive.google.com/thumbnail?id=1Q2Weg85BUxVmO1sXuZaHVzJAh5cyDfHQ&sz=w1000;21SPT0169_240405_et2.jpeg;https://drive.google.com/thumbnail?id=11Dsc0bM-PGNdyvAws5Y0SSD_zpLhvv4c&sz=w1000;21SPT0169_240405_mt2.jpeg;https://drive.google.com/thumbnail?id=12AHwrBXItzYTz1YNDI8cOljSIXs5hfOr&sz=w1000;21SPT0169_240405_az2v.jpeg;https://drive.google.com/thumbnail?id=1e6zxIa4hl6E8q7UmNCO-t4ASj_rOk7pY&sz=w1000;21SPT0169_240405_az2.jpeg;https://drive.google.com/thumbnail?id=1GiX7PCcfTwf65fMYG8yCx3Hx4sHgPkZk&sz=w1000;21SPT0169_240405_et1.jpeg;https://drive.google.com/thumbnail?id=1Z2v8Yk8Xa6XtVjd8T1k0ycl2l0i9u7VN&sz=w1000;21SPT0169_240405_mt1.jpeg;https://drive.google.com/thumbnail?id=1wPvNj2-YJzBuQC2PggKYv7yaZ1s-dg-C&sz=w1000;21SPT0169_240405_az1v.jpeg;https://drive.google.com/thumbnail?id=15nfzF7gUEy7w_XWoW0qV2_vyGBzOBj-v&sz=w1000;21SPT0169_240405_az1.jpeg;https://drive.google.com/thumbnail?id=1NgEgRnORpUiUc2yxJdq2tEWP0_CQ-HNl&sz=w1000;21SPT0169_240405_t4.jpeg;https://drive.google.com/thumbnail?id=1MHh1Q_W_aFo-2spLRFZ5SKFPV10_Pi1k&sz=w1000;21SPT0169_240405_t3.jpeg;https://drive.google.com/thumbnail?id=1o5Wk_bm9Xu4CyYu5kw5V2glXCOqfk4Jm&sz=w1000;21SPT0169_240405_t2.jpeg;https://drive.google.com/thumbnail?id=1a4mnMJaPNYGR9JsHqr16-tQ_4WX-Ogtl&sz=w1000;21SPT0169_240405_t1.jpeg;https://drive.google.com/thumbnail?id=1mpxWXIARLaMYWvYAF3T-Xz8xfHIXKc6U&sz=w1000";
        let resultArray = [];
        let indexArray = 0;
		let mixed = [];
		let updatedMixed = [];

    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300&display=swap" rel="stylesheet">
    <style>
        body,
        html {
            font-family: 'Lato', sans-serif;
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: hsl(219, 100%, 50%);
        }

        .frame-container {
            border: 1px solid rgb(255, 255, 255);
            /* Add border style */
            width: 100%;
            height: 100%;
            margin: 0;
            /* Remove margin */
            padding: 0;
            /* Remove padding */
        }

        #container {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        #topFrame {
            height: 8%;
            background-color: hsl(219, 100%, 50%);
            color: white;
        }

        #bottomFrames {
            flex: 1;
            /* Take up remaining space */
            display: flex;
            flex-direction: row;
        }

        .halfleft {
            width: 90%;
            height: 100%;
            display: flex;
            /* Add flex display */
            flex-direction: column;
            /* Arrange iframes in column */
            background-color: hsl(219, 100%, 50%);
        }

        .halfright {
            flex: 1;
            /* Take up remaining space */
            display: flex;
            flex-direction: column;
        }

        .iframe-container {
            display: flex;
            /* Add flex display */
            flex-direction: column;
            /* Arrange iframes in column */
            flex: 1;
            /* Take up remaining space */
        }


        :root {
            --ref-pos: -70px;
            --ref-pos0: -20px;
            --anim-fast: cubic-bezier(.43, -0.33, .79, .21);
            --anim-vfast: cubic-bezier(.43, -0.33, .79, .21);
            --anim-anticipate: cubic-bezier(.43, -0.33, .79, .21);
            --anim-instant: cubic-bezier(.17, .88, .53, .99);
        }

        .open-sans-thin {
            font-family: "Open Sans", sans-serif;
            font-optical-sizing: auto;
            font-weight: 300;
            font-style: normal;
            font-variation-settings:
                "wdth" 100;
        }

        #lowerdiv {
            z-index: 1;
            background-color: hsl(219, 100%, 50%);
            color: white;
            font-family: Tahoma, Helvetica, sans-serif;
        }

        .subtitle {
            padding-left: 12px;
            padding-top: 15px;
            color: white;
            transition: var(--anim-instant) transform 0.6s;
            transform-origin: left;
        }

        .result {
            padding-left: 12px;
            padding-top: 15px;
            color: white;
            transition: var(--anim-instant) transform 0.6s;
            transform-origin: left;
			font-size: 0.70rem;
        }

        .subtitle:hover {
            transform: scale(1.2);
            /* Make it a little bigger on hover */
        }

        #drop-area {
            z-index: -1;
            line-height: 70px;
            position: relative;
            padding-left: 20px;
            text-align: left;
            background-color: hsl(219, 100%, 40%);
            color: white;
            /* text-shadow: 2px 2px black; */
            /* text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black; */
            /* text-shadow: -2px 0 rgb(128, 128, 128), 0 2px rgb(128, 128, 128), 2px 0 rgb(128, 128, 128), 0 -2px rgb(128, 128, 128); */
            transition: var(--anim-instant) transform 0.6s, opacity 0.6s ease-in;
            top: 8%;
            transform: translateY(var(--ref-pos0));
            opacity: 0;
        }

        #drop-area2 {
            z-index: -1;
            line-height: 40px;
            position: relative;
            padding-left: 20px;
            text-align: left;
            /* background-color: rgb(255, 247, 133); */
            background-color: hsl(219, 100%, 50%);
            color: white;
            /* text-shadow: 2px 2px black; */
            /* text-shadow: -2px 0 rgb(128, 128, 128), 0 2px rgb(128, 128, 128), 2px 0 rgb(128, 128, 128), 0 -2px rgb(128, 128, 128); */
            transition: var(--anim-instant) transform 0.6s, opacity 0.4s ease-in, line-height 0.3s ease-in;
            transition-delay: 0.1s;
            top: 8%;
            transform: translateY(var(--ref-pos));
            opacity: 0;
        }

        #drop-area3 {
            z-index: -1;
            line-height: 40px;
            position: relative;
            padding-left: 20px;
            text-align: left;
            /* background-color: rgba(255, 102, 0, 0.2); */
            background-color: hsl(219, 100%, 40%);
            color: white;
            /* text-shadow: 2px 2px black; */
            /* text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black; */
            /* text-shadow: -2px 0 rgb(128, 128, 128), 0 2px rgb(128, 128, 128), 2px 0 rgb(128, 128, 128), 0 -2px rgb(128, 128, 128); */
            transition: var(--anim-instant) transform 0.6s, opacity 0.2s ease-in, line-height 0.3s ease-in;
            transition-delay: 0.15s;
            top: 8%;
            transform: translateY(calc(var(--ref-pos)*2));
            opacity: 0;
        }

        #lowerdiv:hover .rectangle {
            transform: translateY(0px);
            opacity: 1;
            line-height: 70px;
        }

        #upperdiv {
            background-color: hsl(219, 100%, 50%);
            margin-bottom: -1px;
        }

        #fileInput {
            display: none;
        }

        #uploadStatus {
            padding-left: 20px;
            padding-top: 10px;
            color: white;
            transition: var(--anim-instant) transform 0.6s, opacity 0.4s ease-in, line-height 0.3s ease-in;
            transition-delay: 0.25s;
            top: 8%;
            transform: translateY(calc(var(--ref-pos)*2.6));
            opacity: 0.0;

        }

        #nokia svg {
            transition: var(--anim-instant) transform 0.6s;
        }

        #nokia:hover svg {
            transform: scale(1.1);
            /* Make it a little bigger on hover */
        }

        .search-container {
            margin-top: 10px;
            /* Adjust as needed */
        }

        .search-input {
            margin-left: 10px;
            border: 1px solid #ccc;
            border-radius: 0px;
            font-family: 'Open Sans', sans-serif;
            width: calc(100% - 20px);
            /* 100% width of parent - 20px padding */
            padding: 10px;
            transition: var(--anim-instant) transform 0.6s;
            color: gray;
        }

        .search-button {

            /* Adjust width as needed */
            padding: 5px;
            margin-left: 10px;
            margin-top: 10px;
            width: calc(100% - 20px);
            /* 100% width of parent - 20px padding */
            padding: 10px;
            /* Adjust padding as needed */
            box-sizing: border-box;
            /* Include padding in width calculation */

            border: 1px solid #ccc;
            border-radius: 0px;
            font-family: 'Open Sans', sans-serif;
            transition: var(--anim-instant) transform 0.6s;

            color: rgb(0, 0, 0);
        }

        .search-button:hover {
            cursor: pointer;
            transform: scale(1.05);
            color: rgb(0, 0, 0);
            /* Increase size by 2% */
        }

        .search-input:focus {
            color: black;
            transform: scale(1.05);
            /* Opaque font color on focus */
        }

        .search-input:hover {
            transform: scale(1.05);
            /* Opaque font color on focus */
        }

        iframe {
            /* border: none; */
            height: 100%;
        }
    </style>

    <style>
        /* body {
    font-family: Arial;
    margin: 0;
  } */

        /* body {
      font-family: 'Lato', sans-serif;
    }
   */

        * {
            box-sizing: border-box;
        }

        img {
            vertical-align: middle;
        }

        /* Position the image container (needed to position the left and right arrows) */
        .container {
            position: relative;
        }

        /* Hide the images by default */
        .mySlides {
            display: none;
        }

        .mySlides img {
            height: 80vh;
            /* 85% of the viewport height */
            width: auto;
            /* Auto width to maintain aspect ratio */
            max-width: 100%;
            display: block;
            margin-left: auto;
            margin-right: auto;

        }

        /* Add a pointer when hovering over the thumbnail images */
        .cursor {
            cursor: pointer;
        }

        /* Next & previous buttons */
        .prev,
        .next {
            cursor: pointer;
            position: absolute;
            top: 50%;
            width: auto;
            padding: 16px;
            /* margin-top: -50px; */
            color: white;
            font-weight: bold;
            font-size: 20px;
            border-radius: 0 3px 3px 0;
            user-select: none;
            -webkit-user-select: none;
        }

        /* Position the "next button" to the right */
        .next {
            right: 0;
            border-radius: 3px 0 0 3px;
        }

        .prev {
            left: 0;
            border-radius: 3px 0 0 3px;
        }


        /* On hover, add a black background color with a little bit see-through */
        .prev:hover,
        .next:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }

        /* Number text (1/3 etc) */
        .numbertext {
            color: #f2f2f2;
            font-size: 12px;
            padding: 8px 12px;
            position: absolute;
            top: 0;
        }



        .caption-container {
            background-color: #222;
            padding: 2px 16px;
            font-size: 16px;
            color: white;
        }

        #caption {
            float: right;
        }

        #caption1 {
            float: left;
        }

        /* .row:after {
      content: "";
      display: table;
      clear: both;
    }
  
  
    .column {
      float: left;
      width: 16.66%;
    }
    
    .demo {
      opacity: 0.6;
    } */

        /* Container for image captions */
        .row {
            display: flex;
            flex-wrap: wrap;
            justify-content: left;
            /* Align items in the center horizontally */
            gap: 10px;
            /* Add some space between columns */
        }

        /* Caption image container */
        .column {
            width: 100px;
            /* Fixed width of 100 pixels */
            flex: 0 0 auto;
            /* Ensure the width remains fixed */
        }

        /* Add a transparency effect for thumbnail images */
        .demo {
            opacity: 0.6;
            width: 100%;
            /* Ensure the image fills the column */
            height: auto;
            /* Maintain aspect ratio */
        }

        .active,
        .demo:hover {
            opacity: 1;
        }

        .tooltip {
            position: absolute;
            top: 0;
            left: 0;
            visibility: hidden;
            background-color: #00000080;
            color: #fff;
            font-size: 16px;
            padding: 2px 2px;

            border-radius: 0px;
        }

        .column {
            position: relative;
        }

        .demo:hover+.tooltip {
            visibility: visible;
        }
    </style>

    <style>
        .overlay {
            height: 100%;
            width: 0;
            position: fixed;
            z-index: 1;
            top: 0;
            left: 0;
            background-color: rgb(0, 0, 0);
            background-color: rgba(0, 0, 0, 0.8);
            overflow-x: hidden;
            transition: 0.5s;
            color: white
        }


        .overlay a {
            padding: 8px;
            text-decoration: none;
            font-size: 36px;
            color: #818181;
            display: block;
            transition: 0.5s;
        }


        .overlay a:hover,
        .overlay a:focus {
            color: #f1f1f1;
        }

        .overlay {
            position: absolute;
            top: 0px;
            right: 45px;
            font-size: 15px;
        }

        .closebtn {
            position: absolute;
            top: 0px;
            right: 10px;
            font-size: 15px;
            z-index: 9999;
        }
    </style>

	<style>
	  .azmt-input {
/* 	    display: none;              */
	    box-sizing: content-box;     /* we size by ch units */
	    padding: 6px;
	    font-size: 13px;
	    border-radius: 4px;
	    border: 1px solid #ccc;
	    min-width: 3ch;              /* smallest width */
	    line-height: 1;
	    vertical-align: middle;
	    margin-right: 6px;
	  }
	
	  /* optional: slightly different min-width for inputyx (lat lon) */
	  #inputyx.azmt-input { min-width: 17ch; }

		/* split gallery + resizer */
		.gallery-split{display:flex;gap:8px;height:80vh;align-items:stretch}
		.gallery-left{width:45%;min-width:220px;max-width:75%}
		.gallery-left iframe{width:100%;height:100%;border:0;display:block}
		#galleryResizer{width:8px;cursor:col-resize;background:rgba(0,0,0,0.06)}
		.gallery-right{flex:1 1 0;min-width:300px;overflow:auto}
		/* footer area below the split that will hold caption-container + thumbnails */
		.gallery-bottom { margin-top: 8px; padding: 6px 0; width: 100%; box-sizing: border-box; }


		/* ---- QTD toaster (top-center) ---- */
		#qtd-toast {
		  position: fixed;
		  top: 12px;
		  left: 50%;
		  transform: translateX(-50%) translateY(-200%);
		  z-index: 99999;
		  min-width: 240px;
		  max-width: 90vw;
		  padding: 12px 18px;
		  border-radius: 10px;
		  color: white;
		  font-weight: 600;
		  text-align: center;
		  box-shadow: 0 10px 30px rgba(0,0,0,0.35);
		  opacity: 0;
		  pointer-events: none;
		  will-change: transform, opacity;
		}

		/* success / error colours */
		#qtd-toast.qtd-success { background: linear-gradient(180deg, #29a745, #22863a); }
		#qtd-toast.qtd-error   { background: linear-gradient(180deg, #d64545, #b33434); }

		/* entrance animation (drop with soft elastic/overshoot) */
		@keyframes qtd-toast-drop {
		  0%   { transform: translateX(-50%) translateY(-220%) scale(0.95); opacity: 0; }
		  60%  { transform: translateX(-50%) translateY(10px) scale(1.03); opacity: 1; }
		  80%  { transform: translateX(-50%) translateY(-6px) scale(0.995); opacity: 1; }
		  100% { transform: translateX(-50%) translateY(0) scale(1); opacity: 1; }
		}

		/* hide animation: move up and fade out */
		@keyframes qtd-toast-upfade {
		  0%   { transform: translateX(-50%) translateY(0); opacity: 1; }
		  100% { transform: translateX(-50%) translateY(-48px); opacity: 0; }
		}

		/* utility classes applied from JS */
		#qtd-toast.qtd-show { animation: qtd-toast-drop 700ms cubic-bezier(.22,1.4,.33,1) forwards; pointer-events:auto; }
		#qtd-toast.qtd-hide { animation: qtd-toast-upfade 700ms ease-in forwards; pointer-events:none; }

		/* small text wrap/tidy */
		#qtd-toast .qtd-msg { display:block; font-size:14px; line-height:1.2; word-break:break-word; white-space:normal; }

		/* Inputs start hidden and animate into view when caption1 div gets class `qtd-inputs-visible` */
		#caption1 > div .azmt-input {
		  display: none;                /* hidden initially */
		  opacity: 0;
		  transform: translateY(-6px);
		  transition: opacity 240ms ease, transform 240ms ease;
		  pointer-events: none;
		}

		/* When wrapper gets this class, inputs that are set to display:inline-block (by JS or previous logic)
		   will animate from the above state into visible state. */
		#caption1 > div.qtd-inputs-visible .azmt-input {
		  /* JS will set element.style.display='inline-block' for inputs with value.
			 The CSS below drives the animation */
		  opacity: 1;
		  transform: translateY(0);
		  pointer-events: auto;
		}

		/* keep apply button layout unchanged; it sits next to downloadKMLBtn as before */
		#caption1 > div button { vertical-align: middle; }
			
			
	</style>
		
</head>

<body>
    <div id="container">
        <div id="topFrame">
            <span id="nokia" style="margin-left: 15px;">
                <svg xmlns="http://www.w3.org/2000/svg" width="90" height="40" viewBox="0 0 55 13" fill="none"
                    style="margin-top: 11px;">
                    <g clip-path="url(#clip0_1370_711152)">
                        <path
                            d="M38.0192 0.395349V12.6046H39.842V0.395349H38.0192ZM18.5454 0.186787C14.9944 0.186771 12.2392 2.78308 12.2392 6.5C12.2392 10.3843 14.9944 12.8133 18.5454 12.8132C22.0964 12.8132 24.8572 10.3843 24.8516 6.5C24.8464 2.97836 22.0964 0.186803 18.5454 0.186787ZM23.0321 6.5C23.0321 9.25164 21.0233 11.0752 18.5454 11.0752C16.0674 11.0752 14.0587 9.25164 14.0587 6.5C14.0587 3.79827 16.0674 1.92486 18.5454 1.92486C21.0233 1.92486 23.0321 3.79827 23.0321 6.5ZM0 1.10175e-06V12.6046H1.86027V4.27476L11.5273 13V10.3867L0 1.10175e-06ZM26.2225 6.5L32.9874 12.6047H35.6999L28.9248 6.5L35.6999 0.395343H32.9874L26.2225 6.5ZM55 12.6046H52.9948L51.5285 9.90093H44.8871L43.4206 12.6046H41.4153L43.8437 8.09822H50.5748L47.2185 1.83556L48.2078 0L55 12.6046Z"
                            fill="white"></path>
                    </g>
                    <defs>
                        <clippath id="clip0_1370_711152">
                            <rect width="73" height="12.361" fill="white"></rect>
                        </clippath>
                    </defs>
                </svg>
            </span>
        </div>


        <div id="bottomFrames">
            <div class="halfleft">
                <!-- <div class="frame-container" id="leftBottomFrame"></div> -->
                <iframe id="leftBottomFrame"
                    src="about:blank"
					allow="clipboard-write; clipboard-read; geolocation; microphone; camera; accelerometer; gyroscope; autoplay">					
					</iframe>
            </div>
            <div class="halfright">
                <div class="iframe-container">
                    <div class="frame-container" id="upperdiv">
                        <div class="subtitle open-sans-thin">Search</div>
                        <div class="search-container" id="searchContainer">
                            <input type="text" id="searchInput" class="search-input" value="Site ID"
                                onclick="clearValue()" onblur="resetValue()">
                            <button onclick="searchSite()" class="search-button">Search</button>
                        </div>
                        <div>
                            <div id="myNav" class="overlay">
                                <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
                                <div class="overlay-content">
                                </div>
                            </div>

                            <div class="result  open-sans-thin" id="searchResult"></div>
                        </div>

                    </div>
                </div>
                <div class="iframe-container">
                    <div class="frame-container open-sans-thin" id="lowerdiv">
                        <div class="subtitle open-sans-thin" id="uploader">Uploader</div>
                        <div id="drop-area" class="rectangle open-sans-thin">Java
                        </div>
                        <div id="drop-area2" class="rectangle open-sans-thin">Sumatra
                        </div>
                        <div id="drop-area3" class="rectangle open-sans-thin">Kalimantan
                        </div>
                        <input type="file" accept="image/*" multiple id="fileInput">
                        <div id="uploadStatus" class="status open-sans-thin">testing</div>
                        <div id="imageContainer"></div>
                        <img src="" alt="">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>

// Auto-fit helper (ES5). Paste once in your script (global scope).
		(function () {
		  if (window.__qtdMapAutoFit) return;
		  window.__qtdMapAutoFit = {
			state: null
		  };

		  function measureAndShow(target, siteid) {
			try {
			  var r = target.getBoundingClientRect();
			  var w = Math.max(1, Math.round(r.width));
			  var h = Math.max(1, Math.round(r.height));
			  window.__qtdPersistentMap.showAtRect({
				left: Math.round(r.left),
				top: Math.round(r.top),
				width: w,
				height: h
			  }, siteid);
			} catch (e) { console.warn('measureAndShow failed', e); }
		  }

		  window.startMapAutoFit = function (targetEl, siteid) {
			try {
			  if (!targetEl || !window.__qtdPersistentMap) return;
			  // stop previous if any
			  window.stopMapAutoFit();

			  // immediate show
			  measureAndShow(targetEl, siteid);

			  var ro = null, mo = null, onResize = null;

			  // ResizeObserver if available
			  if (typeof window.ResizeObserver === 'function') {
				ro = new ResizeObserver(function () {
				  // batch layout reads
				  requestAnimationFrame(function () { measureAndShow(targetEl, siteid); });
				});
				try { ro.observe(targetEl); } catch (e) { ro = null; }
			  } else {
				// fallback: window resize
				onResize = function () { requestAnimationFrame(function () { measureAndShow(targetEl, siteid); }); };
				window.addEventListener('resize', onResize);
			  }

			  // MutationObserver to detect subtree/content changes (helps older browsers)
			  try {
				if (typeof window.MutationObserver === 'function') {
				  mo = new MutationObserver(function () {
					requestAnimationFrame(function () { measureAndShow(targetEl, siteid); });
				  });
				  mo.observe(targetEl, { childList: true, subtree: true, attributes: true });
				}
			  } catch (e) { mo = null; }

			  window.__qtdMapAutoFit.state = { target: targetEl, ro: ro, mo: mo, onResize: onResize };
			} catch (err) { console.warn('startMapAutoFit error', err); }
		  };

		  window.stopMapAutoFit = function () {
			try {
			  var s = window.__qtdMapAutoFit.state;
			  if (!s) return;
			  if (s.ro && typeof s.ro.disconnect === 'function') try { s.ro.disconnect(); } catch (e) {}
			  if (s.mo && typeof s.mo.disconnect === 'function') try { s.mo.disconnect(); } catch (e) {}
			  if (s.onResize) try { window.removeEventListener('resize', s.onResize); } catch (e) {}
			  window.__qtdMapAutoFit.state = null;
			} catch (err) { console.warn('stopMapAutoFit error', err); }
		  };
		})();


		(function ensurePersistentMapOnce() {
		  if (window.__qtdPersistentMap) return;
		  // create holder outside overlay so overlay DOM swaps never touch iframe
		  var holder = document.createElement('div');
		  holder.id = 'qtd-persistent-map-holder';
		  holder.style.position = 'fixed';
		  holder.style.left = '0px';
		  holder.style.top = '0px';
		  holder.style.width = '0px';
		  holder.style.height = '0px';
		  holder.style.zIndex = '9998';
		  holder.style.display = 'none';
		  holder.style.background = 'transparent';
		  // append immediately
		  (document.body || document.documentElement).appendChild(holder);

		  var iframe = document.createElement('iframe');
		  iframe.id = 'persistentMapFrame';
		  iframe.allow = 'clipboard-write; clipboard-read; geolocation; microphone; camera; accelerometer; gyroscope; autoplay';
		  iframe.style.width = '100%';
		  iframe.style.height = '100%';
		  iframe.style.border = '0';
		  // load base map once (do not change src later)
		  iframe.src = 'https://script.google.com/macros/s/AKfycbyEe0NDV8L3NLw6cOWazscYLtiJo8QeLjztuORcwgs0roZR8cJyK7jZO1lMNfHKm9aq1g/exec';
		  // optional ready flag
		  iframe.addEventListener('load', function () {
			iframe.dataset.ready = '1';
			try { console.debug('persistentMapFrame loaded (once):', iframe.src); } catch (e) {}
		  }, false);

		  holder.appendChild(iframe);

		  // public API to show/hide and set site via postMessage
		  window.__qtdPersistentMap = {
			holder: holder,
			iframe: iframe,
			showAtRect: function (rect, siteid) {
			  // rect: {left, top, width, height} in viewport coords
			  holder.style.left = (rect.left | 0) + 'px';
			  holder.style.top = (rect.top | 0) + 'px';
			  holder.style.width = (rect.width | 0) + 'px';
			  holder.style.height = (rect.height | 0) + 'px';
			  holder.style.zIndex = 9998;
			  holder.style.display = 'block';
			  try {
				if (iframe.contentWindow && typeof iframe.contentWindow.postMessage === 'function') {
				  iframe.contentWindow.postMessage({ type: 'setSite', siteid: siteid }, '*');
				  iframe.dataset.lastSite = siteid || '';
				}
			  } catch (e) { console.warn('postMessage failed', e); }
			},
			hide: function () {
			  holder.style.display = 'none';
			}
		  };
		})();


		function autoResizeInput(input) {
		  // +1 so it never fully collapses
		  input.style.width = (input.value.length + 1) + "ch";
		}
		


		
		let currentGalleryIndex = 0; // to remember the last opened index
		
        var spanElement = document.getElementById("nokia");
        spanElement.addEventListener("click", function () {
            var url = "https://docs.google.com/spreadsheets/d/1IEJfF9k-73fK2GOEOsy53R7jp6GoRUswhx388xLJcRw";
            window.open(url, "_blank");
        });

        var uploaderElement = document.getElementById("uploader");
        uploaderElement.addEventListener("click", function () {
            var url = "https://drive.google.com/drive/folders/1CvPDze6Ye7gjrNnHxtY2ScZiwSsrZsGy";
            window.open(url, "_blank");
        });


        function showSearchContainer() {
            var searchContainer = document.getElementById("searchContainer");
            searchContainer.style.display = "block";
        }

        function clearValue() {
            var searchInput = document.getElementById("searchInput");
            if (searchInput.value === "Site ID") {
                searchInput.value = "";
            }

        }

        function resetValue() {
            var searchInput = document.getElementById("searchInput");
            if (searchInput.value === "") {
                searchInput.value = "Site ID";
            }
        }

        function searchSite() {
            // Your search functionality here
			document.querySelectorAll('.iframe-container')[1].style.display = "none";
			document.getElementById("upperdiv").style.height = "100%";			
            startTime = performance.now();
            let intervalID = setInterval(updateDuration, 100);
            let isSending = false;
            const sendQueue = [];
            
            function sendPostRequest(foldername, newfolder, folders, folderId) {
                return new Promise((resolve, reject) => {
                    const requestData = {
                        folder: foldername,
                        newfolder: newfolder,
                        folders: folders,
                        folderId: folderId
                    };
                    console.log("search folderId=",folderId);
                    sendQueue.push({ requestData, resolve, reject });

                    if (!isSending) {
                        processQueue();
                    }
                });
            }

            function processQueue() {
                if (sendQueue.length === 0) {
                    isSending = false;
                    return;
                }

                isSending = true;
                const { requestData, resolve, reject } = sendQueue.shift();


                fetch(url, {
                    redirect: "follow",
                    method: 'POST',
                    body: JSON.stringify(requestData),
                    headers: {
                        "Content-Type": "text/plain;charset=utf-8",
                    },
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}`);
                        }
                        return response.text();
                    })
                    .then(responseData => {
                        console.log("server's respond:" + responseData);
                        resolve(responseData);
                        processQueue(); // Process next request
                    })
                    .catch(error => {
                        console.error('Error:', error.message);
                        reject(error);
                        processQueue(); // Process next request
                    });
            }

            function updateDuration() {
                const endTime = performance.now();
                const duration = ((endTime - startTime) / 1000).toFixed(1);
                var searchResult = document.getElementById("searchResult");
                searchResult.innerHTML = "\nSearching.. <i>" + duration + " sec</i>";
            }

            



            //uploadStatus.innerText = "\nUpload successful (" + duration + " sec)" + "\nNow creating slide..";
            var searchInput = document.getElementById("searchInput");
            console.log('searchInput', searchInput.value);

            searchInput.value = searchInput.value.toUpperCase();
            sendPostRequest('search', true, searchInput.value, folder_all).then(responseData => {

                // To stop the interval, call clearInterval with the interval ID
                clearInterval(intervalID);

                console.log("response:", responseData);
                if (responseData.startsWith("search done")) {

                    resultArray = [];
                    indexArray = 0;
                    var searchResult = document.getElementById("searchResult");
                    searchResult.innerHTML = "Nothing";

                    return_url = responseData;
                    let sites = return_url.split('\\');
                    console.log("sites:", sites);
                    for (let j = 0; j < sites.length - 1; j++) {
                        if (sites[j].charAt(sites[j].length - 1) === ';') {
                            sites[j] = sites[j].substring(0, sites[j].length - 1);
                        }
                        let parts = [];
                        if (j === 0) {
                            parts = sites[j].split(';').slice(1);
                            searchResult.innerHTML = "Result";
                        } else {
                            parts = sites[j].split(';');
                        }

                        console.log("parts:", parts);
                        // Initialize an empty array to store objects
                        // resultArray = [];
                        let siteArray = [];
                        // Loop through the parts array and create objects
                        for (let i = 0; i < parts.length; i += 2) {
                            let filename_parts = parts[i].split('.')[0].split('_');
                            let site = filename_parts[0] + '_' + filename_parts[1];
                            let name = filename_parts.slice(2).join('_');
                            let url = parts[i + 1];
                            // resultArray.push({ site, name, url });
                            siteArray.push({ site, name, url });
                        }
                        resultArray.push(siteArray);
                        console.log("resultArray:", resultArray);
                        console.log("siteArray:", siteArray);
						
                        // searchResult.innerHTML += '<br><span style="font-size:14px;cursor:pointer" onclick="openNav(\'' + json + '\')">' + resArr[0].site + '</span>';
                        searchResult.innerHTML += '<br><span style="cursor:pointer" onclick="openNav(' + indexArray + ')">' + siteArray[0].site + '</span>';
                        indexArray = indexArray + 1;

                        // console.log(searchResult.innerHTML);

                        // // Loop through the resultArray and log site, name, and url of each object
                        // for (let obj of resultArray) {
                        //     console.log("Site:", obj.site);
                        //     console.log("Name:", obj.name);
                        //     console.log("URL:", obj.url);
                        // }
                    }
										
					if (indexArray > 0) {
						(async () => {
							// global mixed
							mixed = [];

							for (const group of resultArray) {
								const siteid = group[0].site.split('_')[0];
								const azItems = group.filter(item => item.name.includes("az"));
								if (azItems.length > 0) {
									mixed.push([siteid, ...azItems.flatMap(i => [i.name, i.url])]);
								}
							}

							const uniqueSiteids = [...new Set(mixed.map(m => m[0]))];

							const siteidToAzValues = Object.fromEntries(await Promise.all(
								uniqueSiteids.map(async siteid => {
									const res = await fetch(lastqtdaz, {
										method: 'POST',
										headers: { 'Content-Type': 'text/plain' },
										body: JSON.stringify({ siteid })
									});
									const json = await res.json();
									return [siteid, json];
								})
							));
							
							console.log("siteidToAzValues:", siteidToAzValues);
							
							  updatedMixed = mixed.map(row => {
							  const siteid = row[0];
							  const azValues = siteidToAzValues[siteid] || {};

							  const longitude = azValues.longitude || '';
							  const latitude = azValues.latitude || '';

							  const updatedRow = [siteid, longitude, latitude];

							  for (let i = 1; i < row.length; i += 2) {
								const name = row[i];
								const url = row[i + 1];

								const baseAz = Object.keys(azValues).find(
								  azKey => name.startsWith(azKey) && azKey !== 'longitude' && azKey !== 'latitude'
								);
								const value = baseAz ? `=${azValues[baseAz]}` : '';
								updatedRow.push(name + value, url);
							  }

							  return updatedRow;
							});							

							console.log("updatedMixed:", updatedMixed);
				
							openNav(0);
						})(); // <--- this is an immediately-invoked async function expression (IIFE)
					}
					
                }
            })
                .catch(error => {
                    console.error("Error:", error);
                    // Handle errors if the request fails
                });
            

        }


        let slideIndex = 1;
        // showSlides(slideIndex);

        function plusSlides(n) {
            showSlides(slideIndex += n);
        }

        function currentSlide(n) {
            showSlides(slideIndex = n);
        }

        function showSlides(n) {
            let i;
            let slides = document.getElementsByClassName("mySlides");
            let dots = document.getElementsByClassName("demo");
            let captionText = document.getElementById("caption");
            let captionText1 = document.getElementById("caption1");
            if (n > slides.length) { slideIndex = 1 }
            if (n < 1) { slideIndex = slides.length }
            for (i = 0; i < slides.length; i++) {
                slides[i].style.display = "none";
            }
            for (i = 0; i < dots.length; i++) {
                dots[i].className = dots[i].className.replace(" active", "");
            }
            slides[slideIndex - 1].style.display = "block";
            dots[slideIndex - 1].className += " active";
            captionText.innerHTML = dots[slideIndex - 1].alt;
			if (!document.getElementById("downloadKMLBtn")) {			
				if (dots[slideIndex - 1].alt.charAt(0) === 'b') {
					captionText1.innerHTML = "AFTER";
				} else {
					captionText1.innerHTML = "BEFORE";
				}
			}
		}



        function openNav(idx) {
            // let resArr = JSON.parse(jsonString);
			currentGalleryIndex = idx;
            resArr = resultArray[idx];
            //console.log('openNav resArr:' + resArr);
            createGalery();

            slideIndex = 1;
            showSlides(slideIndex);

            document.getElementById("myNav").style.width = "100%";
            var lowerdiv = document.getElementById('lowerdiv');
            lowerdiv.style.transition = "opacity 0.3s";
            lowerdiv.style.opacity = "0";

        }



		
		function createGalery() {
		    // 1. Render slideshow exactly as before
		    let template = `
		<div class="container">
		{slides}
		<a class="prev" onclick="plusSlides(-1)">❮</a>
		<a class="next" onclick="plusSlides(1)">❯</a>
		</div>
		<div class="caption-container">
		    <span id="caption1"></span><span id="caption"></span><h2 style="text-align:center">{site}</h2>
		</div>
		<div class="container">
		  <div class="row">
		    {thumbnails}
		  </div>
		</div>
		`;
		
		    let slidesHTML = "";
		    let thumbnailsHTML = "";
		    let placemarkName = resArr[0].site;            // e.g. "20SAG0132_2025709"
		    let rawSiteid     = placemarkName.split("_")[0]; // e.g. "20SAG0132"
		
		    resArr.forEach((obj, index) => {
		        slidesHTML += `
		<div class="mySlides">
		  <div class="numbertext">${index + 1} / ${resArr.length}</div>
		  <img src="${obj.url}">
		</div>`;
		        thumbnailsHTML += `
		<div class="column">
		  <img class="demo cursor" src="${obj.url}" style="width:100%" onclick="currentSlide(${index + 1})" alt="${obj.name}">
		  <div class="tooltip">${obj.name}</div>
		</div>`;
		    });
		

			// safer DOM replace (no moving/attaching iframe here)
			var overlayEl = document.querySelector('.overlay-content');
			if (!overlayEl) {
			  console.warn('createGalery: overlay-content not found');
			} else {
			  var htmlText = template
				.replace("{site}", placemarkName)
				.replace("{slides}", slidesHTML)
				.replace("{thumbnails}", thumbnailsHTML);
			  var fragment = document.createRange().createContextualFragment(htmlText);
			  overlayEl.replaceChildren(fragment);
			  console.debug('overlay-content replaced via fragment for', placemarkName);
			  // NOTE: we no longer move or touch persistentMapFrame here. positioning is done by wrapGalleryWithMap.
			}
			


		    // 2. Lookup in updatedMixed for coordinates & az entries
		    const row = updatedMixed.find(r => r[0] === rawSiteid) || [];
		    const [ , longitude = "", latitude = "", ...azPairs ] = row;
		
		    // Build kmlImages from azPairs (name, url alternating)
		    const kmlImages = [];
		    for (let i = 0; i < azPairs.length; i += 2) {
		      const name = azPairs[i];
		      const url  = azPairs[i + 1];
			  if (name && url && !/w/i.test(name)) {
				kmlImages.push({ name, url });
			  }
		  
		    }
		
			// Step 2b: Concatenate only names without 'v' or 'w' (case-insensitive)
			const nameList = kmlImages
			  .filter(item => !/[vw]/i.test(item.name))
			  .map(item => {
				const parts = item.name.split('=');
				return parts.length > 1 ? parts[1] : ''; // extract right side of '='
			  })
			  .filter(Boolean) // remove empty strings
			  .join(' ');
		
		    // 3. Inject & style the KML button    
			const caption1 = document.getElementById("caption1");
			caption1.innerHTML = `
			  <div style="display:flex;align-items:center;gap:10px;margin-top:8px;flex-wrap:wrap;">
			    <button id="downloadKMLBtn" style="
			      padding:8px 16px;
			      background-color:#0066cc;
			      color:white;
			      border:none;
			      border-radius:5px;
			      cursor:pointer;
			      font-size:14px;
			      transition:background-color 0.2s ease;">
			      KML ${rawSiteid}
			    </button>
			
			    <!-- combined lat lon input -->
			    
				<input id="inputrows" placeholder="rows" title="rows" style="display:none;"> 
				
				<input id="inputyx" class="azmt-input" placeholder="lat lon (H I)" title="Column H (lat) and I (lon) combined">
				
				<input id="inputaz1" class="azmt-input" placeholder="az1 (G)" title="Column G - az1">
				<input id="inputaz2" class="azmt-input" placeholder="az2 (G)" title="Column G - az2">
				<input id="inputaz3" class="azmt-input" placeholder="az3 (G)" title="Column G - az3">
				<input id="inputaz4" class="azmt-input" placeholder="az4 (G)" title="Column G - az4">
				
				<input id="inputmt1" class="azmt-input" placeholder="mt1 (F)" title="Column F - mt1">
				<input id="inputmt2" class="azmt-input" placeholder="mt2 (F)" title="Column F - mt2">
				<input id="inputmt3" class="azmt-input" placeholder="mt3 (F)" title="Column F - mt3">
				<input id="inputmt4" class="azmt-input" placeholder="mt4 (F)" title="Column F - mt4">
		
			    <!-- Apply starts disabled/loading until populate finishes -->
			    <button id="applyAzBtn" disabled style="padding:6px 10px;border-radius:5px;background:#888;color:#fff;border:none;cursor:not-allowed;font-size:13px;">
			      Loading...
			    </button>
			  </div>
			`;
		
		
		
		    const btn = document.getElementById('downloadKMLBtn');
		    btn.addEventListener("mouseenter", () => btn.style.backgroundColor = "#004c99");
		    btn.addEventListener("mouseleave", () => btn.style.backgroundColor = "#0066cc");
		    btn.addEventListener("mousedown", () => btn.style.backgroundColor = "#003d80");
		    btn.addEventListener("mouseup", () => btn.style.backgroundColor = "#004c99");

			
			// populate inputs from GAS (same endpoint used elsewhere: lastqtdaz / url)
			(async function populateAndWire() {
			  try {
			    const applyBtn = document.getElementById('applyAzBtn');

				Array.prototype.forEach.call(document.querySelectorAll('.azmt-input'), function(input){
				  autoResizeInput(input);
				  input.addEventListener('input', function(){ autoResizeInput(input); });
				});
				  
			    // store original style/text to restore later
				const origApplyText = 'Apply';
				const origApplyBg = '#008000';
				const origApplyCursor = 'pointer';
			
			    // ensure button is disabled + loading state while fetching
			    if (applyBtn) {
			      applyBtn.disabled = true;
			      applyBtn.style.backgroundColor = '#888';
			      applyBtn.style.cursor = 'not-allowed';
			      applyBtn.textContent = 'Loading...';
			    }
			
			    // request server for this siteid's saved values
			    const resp = await fetch(lastqtdaz, {
			      method: 'POST',
			      headers: { 'Content-Type': 'text/plain' },
			      body: JSON.stringify({ siteid: rawSiteid })
			    });
			
			    let data;
			    try {
			      data = await resp.json();
			    } catch (e) {
			      // if not JSON, try text
			      const t = await resp.text();
			      try { data = JSON.parse(t); } catch (ee) { data = {}; }
			    }
			
			    // tolerant helpers to find lat/lon and columns
			    const setIf = (id, v) => {
			      const el = document.getElementById(id);
			      if (el) el.value = (v === undefined || v === null) ? '' : String(v);
			    };
			
			    // Extract list helper (separate for AZ (G) and MT (F))
			    function extractListFrom(obj, colKeys) {
			      if (!obj) return [];
			      if (typeof obj === 'string') {
			        if (obj.includes(';')) return obj.split(';').map(s => s.trim()).filter(Boolean);
			        return [obj.trim()].filter(Boolean);
			      }
			      for (const k of colKeys) {
			        if (obj[k] && typeof obj[k] === 'string') {
			          if (obj[k].includes(';')) return obj[k].split(';').map(s => s.trim()).filter(Boolean);
			          if (obj[k].trim() !== '') return [obj[k].trim()];
			        }
			      }
			      // az1/az2 etc
			      const azKeys = Object.keys(obj).filter(k => /^az/i.test(k)).sort();
			      if (azKeys.length) return azKeys.map(k => String(obj[k] || '').trim()).filter(Boolean);
			      // rows array
			      if (Array.isArray(obj.rows) && obj.rows.length) {
			        const res = [];
			        for (const r of obj.rows) {
			          for (const k of colKeys) {
			            if (r[k]) {
			              if (String(r[k]).includes(';')) {
			                res.push(...String(r[k]).split(';').map(s => s.trim()).filter(Boolean));
			              } else {
			                res.push(String(r[k]).trim());
			              }
			            }
			          }
			        }
			        return res;
			      }
			      return [];
			    }
			
			    // AZ candidates from column G
			    const azCandidates = extractListFrom(data, ['G','g','az','AZ','Az']);
			    // MT candidates from column F (IMPORTANT: separate extraction)
			    const mtCandidates = extractListFrom(data, ['F','f','mt','MT','Mt']);
			
			    // fallback: if rows provided as array-of-rows structure with explicit G/F properties
			    // (this is covered above in extractListFrom using rows but left as extra guard)
			    if ((!azCandidates || azCandidates.length === 0) && Array.isArray(data.rows) && data.rows.length) {
			      for (const r of data.rows) {
			        if (r.G) azCandidates.push(String(r.G).trim());
			      }
			    }
			    if ((!mtCandidates || mtCandidates.length === 0) && Array.isArray(data.rows) && data.rows.length) {
			      for (const r of data.rows) {
			        if (r.F) mtCandidates.push(String(r.F).trim());
			      }
			    }
			
			    // set combined lat/lon if present separately in data
			
			    // set combined lat/lon if present separately in data (prefer explicit fields)
			    const possibleLat = data.latitude || data.lat || data.LATITUDE || data.H || data.h || '';
			    const possibleLon = data.longitude || data.lon || data.LONGITUDE || data.I || data.i || '';
			
			    if (possibleLat || possibleLon) {
			      // prefer returned latitude/longitude if provided
			      setIf('inputyx', (possibleLat || '') + (possibleLat && possibleLon ? ' ' : '') + (possibleLon || ''));
			    } else {
			      // fallback: combined field
			      const combined = data.latlon || data.lat_lon || data['H;I'] || '';
			      if (combined) setIf('inputyx', combined);
			    }
			
			    // Prefer explicit az1..az4 and mt1..mt4 from server response; fall back to azCandidates / mtCandidates
			    for (let i = 1; i <= 4; i++) {
			      const azKey = 'az' + i;
			      const mtKey = 'mt' + i;
			      const azVal = (data[azKey] !== undefined && data[azKey] !== null && String(data[azKey]).trim() !== '') ?
			                    String(data[azKey]).trim() : (azCandidates[i - 1] || '');
			      const mtVal = (data[mtKey] !== undefined && data[mtKey] !== null && String(data[mtKey]).trim() !== '') ?
			                    String(data[mtKey]).trim() : (mtCandidates[i - 1] || '');
			      setIf('inputaz' + i, azVal);
			      setIf('inputmt' + i, mtVal);
			    }
			
			    // Show / hide inputs 2..4 individually depending on whether they have values
			    ['2','3','4'].forEach(n => {
			      const azEl = document.getElementById('inputaz' + n);
			      const mtEl = document.getElementById('inputmt' + n);
			      if (azEl) azEl.style.display = (azEl.value && azEl.value.trim() !== '') ? 'inline-block' : 'none';
			      if (mtEl) mtEl.style.display = (mtEl.value && mtEl.value.trim() !== '') ? 'inline-block' : 'none';
			    });
			
			    // create (if missing) a hidden input 'inputrows' and set it to rows joined by ';'
			    let inputRowsEl = document.getElementById('inputrows');
			    if (!inputRowsEl) {
			      inputRowsEl = document.createElement('input');
			      inputRowsEl.type = 'hidden';
			      inputRowsEl.id = 'inputrows';
			      // append hidden input near caption1 so it travels with the gallery/controls
			      const caption1Node = document.getElementById('caption1') || document.getElementById('caption');
			      if (caption1Node) caption1Node.appendChild(inputRowsEl);
			      else document.body.appendChild(inputRowsEl);
			    }
			    if (Array.isArray(data.rows)) {
			      inputRowsEl.value = data.rows.join(';');
			    } else if (typeof data.rows === 'string') {
			      inputRowsEl.value = data.rows;
			    } else {
			      inputRowsEl.value = '';
			    }
			
			    // ensure inputs 2..4 toggle visibility on manual edit as well
			    ['inputaz2','inputaz3','inputaz4','inputmt2','inputmt3','inputmt4'].forEach(id=>{
			      const el = document.getElementById(id);
			      if (!el) return;
			      // avoid adding duplicate listeners: remove old then add new by cloning node
			      const clone = el.cloneNode(true);
			      el.parentNode.replaceChild(clone, el);
			      clone.addEventListener('input', () => {
			        clone.style.display = (clone.value && clone.value.trim() !== '') ? 'inline-block' : 'none';
			      });
			    });
								  
				// // after populating values from server:
				// attachResizers(['inputyx','inputaz1','inputaz2','inputaz3','inputaz4',
				//                'inputmt1','inputmt2','inputmt3','inputmt4']);
				
				// // reveal inputs (shows only inputs that have non-empty value)
				// revealInputs(newApply); 
								  
				  
			    // restore apply button to ready state
			    if (applyBtn) {
				  applyBtn.disabled = false;
				  applyBtn.style.backgroundColor = origApplyBg;
				  applyBtn.style.cursor = origApplyCursor;
				  applyBtn.textContent = origApplyText;
				  // revealInputs(newApply);
				  
					// after you've set all .azmt-input values
					var inputs = document.querySelectorAll('.azmt-input');
					for (var i = 0; i < inputs.length; i++) {
					  var e = document.createEvent('Event');
					  e.initEvent('input', true, true);
					  inputs[i].dispatchEvent(e);
					}		

					// --- reveal: always show certain inputs even if empty, then show other non-empty inputs ---
					try {
					  var captionDiv = document.querySelector('#caption1 > div');
					  if (captionDiv) {
						captionDiv.classList.add('qtd-inputs-visible');

						// Always-show these inputs even when blank (update IDs if yours differ)
						var alwaysShowIds = ['inputyx','inputaz1','inputmt1'];
						for (var j = 0; j < alwaysShowIds.length; j++) {
						  var id = alwaysShowIds[j];
						  var elA = document.getElementById(id);
						  if (elA) {
							elA.style.display = 'inline-block';
							try {
							  var evA = document.createEvent('Event');
							  evA.initEvent('input', true, true);
							  elA.dispatchEvent(evA);
							} catch (eA) {}
						  }
						}

						// Then handle all other .azmt-inputs (show only if non-empty)
						var inputs = captionDiv.querySelectorAll('.azmt-input');
						for (var i = 0; i < inputs.length; i++) {
						  var el = inputs[i];
						  // skip already-handled always-show inputs
						  var sid = el.id || '';
						  if (sid === 'inputyx' || sid === 'inputaz1' || sid === 'inputmt1') continue;

						  var has = el.value && String(el.value).trim() !== '';
						  if (has) {
							el.style.display = 'inline-block';
							try {
							  var ev = document.createEvent('Event');
							  ev.initEvent('input', true, true);
							  el.dispatchEvent(ev);
							} catch (e) {}
						  } else {
							el.style.display = 'none';
						  }
						}

						// force reflow to reliably kick off transitions
						void captionDiv.offsetWidth;
					  }
					} catch (errReveal) {
					  console.warn('reveal inputs failed', errReveal);
					}					
			    }
			

				// ---- toaster helper: showToastAndClose(message, success) ----
				function showToastAndClose(message, success) {
				  // reuse existing toast element if present
				  let toast = document.getElementById('qtd-toast');
				  if (!toast) {
					toast = document.createElement('div');
					toast.id = 'qtd-toast';
					toast.innerHTML = '<span class="qtd-msg"></span>';
					document.body.appendChild(toast);
				  }
				  const msgEl = toast.querySelector('.qtd-msg');
				  msgEl.textContent = message || '';

				  // apply classes
				  toast.classList.remove('qtd-success','qtd-error','qtd-show','qtd-hide');
				  toast.classList.add(success ? 'qtd-success' : 'qtd-error');

				  // force reflow then start entrance animation
				  void toast.offsetWidth;
				  toast.classList.add('qtd-show');

				  // after 3s visible, start hide animation
				  const visibleMs = 3000;
				  // clear any previous timers stored on element
				  if (toast._qtdTimer) { clearTimeout(toast._qtdTimer); toast._qtdTimer = null; }
				  toast._qtdTimer = setTimeout(() => {
					toast.classList.remove('qtd-show');
					toast.classList.add('qtd-hide');
					// when hide animation completes, remove/hide then trigger closebtn
					function onAnimEnd(ev) {
					  if (ev && ev.target !== toast) return;
					  toast.removeEventListener('animationend', onAnimEnd);
					  // remove element from DOM to keep things clean (or keep it hidden for reuse)
					  try { toast.parentNode && toast.parentNode.removeChild(toast); } catch(e){}
					  // trigger close button click (if exists)
					  try {
						const closeBtn = document.querySelector('.closebtn');
						if (closeBtn) {
						  // ensure slight delay so UI has settled
						  setTimeout(() => { closeBtn.click(); }, 40);
						} else {
						  // fallback to calling closeNav() if defined
						  if (typeof closeNav === 'function') setTimeout(closeNav, 40);
						}
					  } catch (err) { console.warn('Toast: could not trigger closebtn', err); }
					}
					// listen for animation end
					toast.addEventListener('animationend', onAnimEnd);
				  }, visibleMs);
				}




			
			    // APPLY button handler: send update request to GAS
			    if (applyBtn) {
			      // remove any old listener by cloning node (safe way to remove handlers)
			      const newApply = applyBtn.cloneNode(true);
			      applyBtn.parentNode.replaceChild(newApply, applyBtn);
			
			      newApply.addEventListener('click', async function () {
			        try {
		
					    // disable button while working
					    newApply.disabled = true;
					
					    // helper: get trimmed value or empty string
					    const getVal = id => {
					      const el = document.getElementById(id);
					      return el ? String(el.value || '').trim() : '';
					    };
					
									
						const inputrows = getVal('inputrows');     // hidden, already semicolon-delimited if created earlier
						const inputyx   = getVal('inputyx');       // "lat lon" combined
						
						// build combined az/mt strings from az1..4 and mt1..4 (only include non-empty items)
						const azs = [1,2,3,4].map(i => getVal('inputaz' + i)).filter(v => v !== '');
						const mts = [1,2,3,4].map(i => getVal('inputmt' + i)).filter(v => v !== '');
						const inputaz = azs.join(';');
						const inputmt = mts.join(';');
										
			          const payload = {
			            action: 'updateAzMt',      // server must handle this action
			            siteid: rawSiteid,
			            inputrows: inputrows,
			            inputyx: inputyx,
			            inputaz: inputaz,
			            inputmt: inputmt
			          };
			
			          // disable button while performing update
			          newApply.disabled = true;
			          newApply.style.backgroundColor = '#888';
			          newApply.style.cursor = 'not-allowed';
			          const prevText = newApply.textContent;
			          newApply.textContent = 'Applying...';
			
			          // POST to your GAS endpoint (same 'url' variable used elsewhere)
			          const r = await fetch(url, {
			            method: 'POST',
			            headers: { 'Content-Type': 'text/plain' },
			            body: JSON.stringify(payload)
			          });
			
			          
						// read response body only once (as text), then try parse JSON from that text
						let rtext = '';
						try {
						  const bodyText = await r.text(); // read once
						  // try parse as JSON, otherwise keep raw text
						  try {
						    const parsed = JSON.parse(bodyText);
						    
						    rtext = typeof parsed === 'string' ? parsed : JSON.stringify(parsed);
						  } catch (je) {
						    rtext = bodyText;
						  }
						} catch (readErr) {
						  console.error('Failed to read response body', readErr);
						  rtext = 'error reading response: ' + String(readErr);
						}
						
						console.log('Update response: ' + rtext);
						
						// decide success vs failure
						const trimmed = (rtext || '').toString().trim();
						if (trimmed === 'ok') {
						  showToastAndClose('Update successful', true);
						} else if (trimmed.toLowerCase().startsWith('error:')) {
						  showToastAndClose('Update failed: ' + rtext, false);
						} else {
						  showToastAndClose('Update response: ' + rtext, false);
						}

		
			
			          // restore apply button
			          newApply.disabled = false;
			          newApply.style.backgroundColor = origApplyBg || '#008000';
			          newApply.style.cursor = origApplyCursor || 'pointer';
			          newApply.textContent = prevText || 'Apply';
			
			        } catch (e) {
			          console.log('Update failed: ' + (e && e.message ? e.message : e));
					  showToastAndClose('Update failed: ' + (e && e.message ? e.message : e), false);
						
			          // restore apply button on failure
			          try {
			            newApply.disabled = false;
			            newApply.style.backgroundColor = origApplyBg || '#008000';
			            newApply.style.cursor = origApplyCursor || 'pointer';
			            newApply.textContent = 'Apply';
			          } catch (ee) {}
			        }
			      });
			    }
			
			  } catch (err) {
			    console.warn('populateAndWire error', err);
			    // restore apply button on error
			    const applyBtnErr = document.getElementById('applyAzBtn');
			    if (applyBtnErr) {
			      applyBtnErr.disabled = false;
			      applyBtnErr.style.backgroundColor = '#008000';
			      applyBtnErr.style.cursor = 'pointer';
			      applyBtnErr.textContent = 'Apply';
			    }
			  }
			})();
		
		
			
		    // 4. Generate KML on click
		    btn.addEventListener('click', function () {
		        const kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
		<kml xmlns="http://www.opengis.net/kml/2.2">
		  <Placemark>
		    <name>${rawSiteid}</name>
		    <Style>
		      <IconStyle>
				<color>ff55ffff</color>
		        <scale>1.0</scale>
		        <Icon>
		          <href>http://maps.google.com/mapfiles/kml/shapes/donut.png</href>
		        </Icon>
		      </IconStyle>
		      <LabelStyle>
				<color>ffffff7f</color>
		        <scale>0.7</scale>
		      </LabelStyle>
		    </Style>	
		    <description><![CDATA[
		<style>
		.tab-container { width:800px; font-family:Arial,sans-serif; text-align:center; }
		.tab-container input { display:none; }
		.tab-links { background:white; padding:5px; text-align:center; }
		.tab-container label {
		  display:inline-block; padding:0 8px; color:#0066cc;
		  text-decoration:underline; cursor:pointer; font-size:14px;
		}
		.tab-container label:hover { text-decoration:none; }
		.tab-container .tab-content {
		  display:none; border-top:1px solid #ccc; margin:10px 0;
		}
		.tab-container input:checked + label { font-weight:bold; text-decoration:none; }
		${kmlImages.map((_, i) => `#tab${i+1}:checked ~ #content${i+1}`).join(',')} {
		  display:block;
		}
		.tab-container img { display:block; margin:0 auto; width:100%; height:auto; }
		</style>
		
		<div class="tab-container">
		  ${kmlImages.map((_, i) =>
		    `<input type="radio" id="tab${i+1}" name="tabs" ${i===0?'checked':''}>`
		  ).join("\n")}
		  <div class="tab-links">
		    ${kmlImages.map((img, i) =>
		      `<label for="tab${i+1}">${img.name}</label>${i<kmlImages.length-1?" | ":""}`
		    ).join("\n")}
		  </div>
		  ${kmlImages.map((img, i) => `
		  <div id="content${i+1}" class="tab-content">
		    <img src="${img.url}">
		    <div class="tab-links">
		      ${kmlImages.map((inner, j) =>
		        `<label for="tab${j+1}">${inner.name}</label>${j<kmlImages.length-1?" | ":""}`
		      ).join("\n")}
		    </div>
		  </div>`).join("\n")}
		</div>
		    ]]></description>
		    <Point>
		      <coordinates>${longitude},${latitude},0</coordinates>
		    </Point>
		  </Placemark>
		</kml>`;
		
		        const blob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
		        const url = URL.createObjectURL(blob);
		
		        const link = document.createElement('a');
		        link.href = url;
		        link.download = `${placemarkName}.kml`;
		        link.click();
		        URL.revokeObjectURL(url);
		    });


			
			function wrapGalleryWithMap(rawSiteid, containerSelector) {
			  containerSelector = containerSelector || '.overlay-content';
			  try {
				var overlay = document.querySelector(containerSelector);
				if (!overlay) return;
				// only skip if we've wrapped and the wrapper element is still present.
				// if the wrapper was removed (innerHTML replaced) we must re-run the wrapping.
				if (overlay.__mapWrapped && overlay.querySelector('.gallery-split')) {
				  return; // already wrapped and wrapper still in DOM
				}
				// helper: find descendant (prefer direct children first)
				function findDescendant(parent, selector) {
				  // prefer direct children
				  for (var i = 0; i < parent.children.length; i++) {
					if (parent.children[i].matches && parent.children[i].matches(selector)) return parent.children[i];
				  }
				  // fallback to any descendant
				  return parent.querySelector(selector);
				}

				// create wrapper regions
				var wrapper = document.createElement('div'); wrapper.className = 'gallery-split';
				var left = document.createElement('div'); left.className = 'gallery-left';
				var resizer = document.createElement('div'); resizer.id = 'galleryResizer';
				var right = document.createElement('div'); right.className = 'gallery-right';
				var footer = document.createElement('div'); footer.className = 'gallery-bottom';

				// reuse persistent iframe if present
				var persistent = document.getElementById('persistentMapFrame');
				if (persistent) {
				  mapNode = persistent;

					console.debug('wrapGalleryWithMap: attaching persistent map into gallery (site=', rawSiteid, ')');
					mapNode.dataset.lastAttached = Date.now();

				  // helper to safely attempt postMessage
				  function tryPostMessageOnce() {
					try {
					  if (mapNode.contentWindow && typeof mapNode.contentWindow.postMessage === 'function') {
						mapNode.contentWindow.postMessage({ type: 'setSite', siteid: rawSiteid }, '*');
						mapNode.dataset.lastSite = rawSiteid || '';
						return true;
					  }
					} catch (err) {
					  console.warn('postMessage attempt failed', err);
					}
					return false;
				  }

					// If postMessage didn't succeed immediately, wait for the persistent iframe's load and try again.
					// IMPORTANT: do NOT change mapNode.src or create a short-lived iframe — that causes reloads.
					if (!tryPostMessageOnce()) {
					  var onLoad = function () {
						tryPostMessageOnce();
						mapNode.removeEventListener('load', onLoad);
					  };
					  mapNode.addEventListener('load', onLoad);
					}
					// (no else branch creating a new iframe here — we must always reuse persistentMapFrame)

				} else {
				  // --- Minimal change: DON'T create a short-lived iframe here ---
				  // Instead, try to reuse/create a persistent iframe so it won't reload repeatedly.
				  var persistent = document.getElementById('persistentMapFrame');

				  // If persistent iframe does not yet exist (rare), create it synchronously once.
				  if (!persistent) {
					persistent = document.createElement('iframe');
					persistent.id = 'persistentMapFrame';
					persistent.style.display = 'none';
					persistent.style.width = '100%';
					persistent.style.height = '100%';
					persistent.allow = 'clipboard-write; clipboard-read; geolocation; microphone; camera; accelerometer; gyroscope; autoplay';
					// load base map once (no site param) — created only once
					persistent.src = 'https://script.google.com/macros/s/AKfycbyEe0NDV8L3NLw6cOWazscYLtiJo8QeLjztuORcwgs0roZR8cJyK7jZO1lMNfHKm9aq1g/exec';
					persistent.addEventListener('load', function () { persistent.dataset.ready = '1'; }, { once: true });
					(document.body || document.documentElement).appendChild(persistent);
				  }

				  // Use the persistent iframe as the map node and move it into the left pane.
				  mapNode = persistent;



					console.debug('wrapGalleryWithMap: attaching persistent map into gallery (site=', rawSiteid, ')');
					mapNode.dataset.lastAttached = Date.now();

				  // Attempt to instruct the map to switch site via postMessage (non-reloading).
				  try {
					if (mapNode.contentWindow && typeof mapNode.contentWindow.postMessage === 'function') {
					  mapNode.contentWindow.postMessage({ type: 'setSite', siteid: rawSiteid }, '*');
					  mapNode.dataset.lastSite = rawSiteid || '';
					} else {
					  // If postMessage not yet available, we do nothing here (no src change).
					  // The persistent iframe will remain loaded and available instantly on next open.
					  console.warn('persistent iframe present but contentWindow/postMessage not ready yet');
					}
				  } catch (err) {
					console.warn('postMessage to persistent iframe failed', err);
				  }
				}




				// find and place the slides container into right
				var containerNode = findDescendant(overlay, '.container');
				if (containerNode) {
				  right.appendChild(containerNode);
				} else {
				  // if no .container found, move the first child that is not map, caption or row into right
				  for (var j = 0; j < overlay.children.length; j++) {
					var ch = overlay.children[j];
					if (ch === mapNode) continue;
					if (ch.classList && (ch.classList.contains('caption-container') || ch.classList.contains('row'))) continue;
					right.appendChild(ch);
					break;
				  }
				}

				// move caption-container and .row (thumbnails) into footer (under the split)
				var captionNode = findDescendant(overlay, '.caption-container');
				if (captionNode) footer.appendChild(captionNode);
				// prefer the thumbnail row that is a direct child first
				var rowNode = null;
				for (var k = 0; k < overlay.children.length; k++) {
				  if (overlay.children[k].classList && overlay.children[k].classList.contains('row')) { rowNode = overlay.children[k]; break; }
				}
				if (!rowNode) rowNode = findDescendant(overlay, '.row');
				if (rowNode) footer.appendChild(rowNode);

				// any remaining nodes (rare) that are still children of overlay and not map/container/footer items
				// leave them alone (minimal change) — if you want them in footer, uncomment the loop below.
				/*
				while (overlay.firstChild) {
				  footer.appendChild(overlay.firstChild);
				}
				*/

				// assemble and insert
				wrapper.appendChild(left);
				wrapper.appendChild(resizer);
				wrapper.appendChild(right);
				overlay.appendChild(wrapper);

				// --- position the fixed holder AFTER wrapper is in DOM ---
				// use requestAnimationFrame so layout is computed before measuring
				if (window.__qtdPersistentMap && typeof window.__qtdPersistentMap.showAtRect === 'function') {

					startMapAutoFit(left, rawSiteid);

				} else {
				  // fallback: if holder not ready, we leave iframe hidden; it will be positioned when available
				  console.warn('wrapGalleryWithMap: qtdPersistentMap not available at append time');
				}


				if (footer.childNodes.length) overlay.appendChild(footer);

				overlay.__mapWrapped = true;

				// resizer logic (unchanged)
				(function () {
				  var startX = 0, startW = 0;
				  function onMove(e) {
					var clientX = (e.touches ? e.touches[0].clientX : e.clientX);
					var parentW = wrapper.getBoundingClientRect().width;
					var dx = clientX - startX;
					var newW = startW + dx;
					if (newW < 200) newW = 200;
					if (newW > parentW - 200) newW = parentW - 200;
					left.style.width = newW + 'px';
					right.style.width = (parentW - newW - 8) + 'px';
				  }
				  function onUp() {
					document.removeEventListener('mousemove', onMove, true);
					document.removeEventListener('mouseup', onUp, true);
					document.removeEventListener('touchmove', onMove, true);
					document.removeEventListener('touchend', onUp, true);
				  }
				  resizer.addEventListener('mousedown', function (e) {
					startX = e.clientX;
					startW = left.getBoundingClientRect().width;
					document.addEventListener('mousemove', onMove, true);
					document.addEventListener('mouseup', onUp, true);
					e.preventDefault();
				  }, false);
				  resizer.addEventListener('touchstart', function (e) {
					startX = e.touches[0].clientX;
					startW = left.getBoundingClientRect().width;
					document.addEventListener('touchmove', onMove, true);
					document.addEventListener('touchend', onUp, true);
					e.preventDefault();
				  }, false);
				})();

				// expose for debugging
				window.__wrappedGallery = { wrapper: wrapper, mapNode: mapNode, containerNode: containerNode, footer: footer, left: left, right: right };
			  } catch (err) {
				if (window.console) console.error('wrapGalleryWithMap error', err);
			  }
			}


			wrapGalleryWithMap(rawSiteid);
			
		}
		


		
		function closeNav() {
		  document.getElementById("myNav").style.width = "0%";
		  lowerdiv.style.transition = "opacity 0.5s 0.5s";
		  lowerdiv.style.opacity = "1";

			stopMapAutoFit();
			window.__qtdPersistentMap.hide();

		}


        document.addEventListener("DOMContentLoaded", function () {
            const images = document.querySelectorAll('.demo');

            images.forEach(image => {
                const altText = image.getAttribute('alt');
                const tooltip = image.nextElementSibling;
                tooltip.textContent = altText;
            });
        });

    </script>

    <script>
        window.onload = function () {
            var topFrame = document.getElementById('topFrame');
            var leftBottomFrame = document.getElementById('leftBottomFrame');
            var upperdiv = document.getElementById('upperdiv');
            var lowerdiv = document.getElementById('lowerdiv');

            function setIframeSizes() {
                var windowHeight = window.innerHeight;
                var topFrameHeight = topFrame.offsetHeight;
                var remainingHeight = windowHeight - topFrameHeight;
                var upperdivHeight = 0.6 * remainingHeight; // You can set the vertical separator dynamically here
                upperdiv.style.height = upperdivHeight + 'px';
                lowerdiv.style.height = (remainingHeight - upperdivHeight) + 'px';

                var halfleft = document.querySelector('.halfleft');
                var newWidth = 90 + '%'; // You can set the horizontal separator here
                halfleft.style.width = newWidth;
                var leftBottomFrameWidth = leftBottomFrame.offsetWidth;
                var remainingWidth = document.getElementById('bottomFrames').offsetWidth - leftBottomFrameWidth;
                upperdiv.style.width = remainingWidth + 'px';
                lowerdiv.style.width = remainingWidth + 'px';
            }

            // function addTextToIframes() {
            //     topFrame.innerHTML = topFrame.innerHTML+'Top Frame: ' + topFrame.id;
            //     leftBottomFrame.innerHTML = 'Left Bottom Frame: ' + leftBottomFrame.id;
            //     upperdiv.innerHTML = 'Upper div: ' + upperdiv.id;
            //     lowerdiv.innerHTML = 'Lower div: ' + lowerdiv.id;
            // }

            setIframeSizes();
            // addTextToIframes();
            window.addEventListener('resize', setIframeSizes);
        }
    </script>

    <!-- script drag drop -->
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const dropArea = document.getElementById("drop-area");
            const dropArea2 = document.getElementById("drop-area2");
            const dropArea3 = document.getElementById("drop-area3");
            const rectangles = document.querySelectorAll('.rectangle');
            const lowerdiv = document.getElementById("lowerdiv");
            let fileInput = document.querySelector("input");
            let imageContainer = document.getElementById("imageContainer");
            let uploadStatus = document.getElementById("uploadStatus");
            let foldername = '';

            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                // dropArea.addEventListener(eventName, preventDefaults, false);
                // dropArea2.addEventListener(eventName, preventDefaults, false);
                // dropArea3.addEventListener(eventName, preventDefaults, false);
                lowerdiv.addEventListener(eventName, preventDefaults, false);
            });

            // Highlight drop area when item is dragged over it            
            document.body.addEventListener('dragenter', preparedrag, false);
            // dropArea.addEventListener('drop', handleDrop, false);
            // dropArea2.addEventListener('drop', handleDrop, false);
            // dropArea3.addEventListener('drop', handleDrop, false);
            lowerdiv.addEventListener('drop', handleDrop, false);

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            function preparedrag(e) {
                e.preventDefault();
                e.stopPropagation();

                console.log('prepare drag');
                var rectangles = lowerdiv.querySelectorAll('.rectangle');
                // Loop through each rectangle and apply the hover effect
                rectangles.forEach(function (rectangle) {
                    rectangle.style.transform = 'translateY(0px)';
                    rectangle.style.opacity = '1';
                    rectangle.style.lineHeight = '70px';
                });
                uploadStatus.style.opacity = '0';

            }

            function postdrag(e) {
                e.preventDefault();
                e.stopPropagation();

            }

            function handleDrop(e) {
                e.preventDefault();
                e.stopPropagation();


                const droppedFiles = e.dataTransfer.files;
                const items = e.dataTransfer.items;

                if (droppedFiles.length === 0) return;

                // Determine which rectangle the drop occurred on
                const rectDroppedOn = getRectangleDroppedOn(e.clientX, e.clientY);
                if (rectDroppedOn) {
                    var sdrop = rectDroppedOn.innerText;

                    // rectDroppedOn.innerText = "dropped";
                    if (sdrop == "Java") {
                        // dropArea2.style.transform='translateY(-var(--ref-pos))';
                        dropArea2.style.opacity = 0;
                        // dropArea3.style.transform='translateY(-calc(var(--ref-pos)*2))'
                        dropArea3.style.opacity = 0;
                        dropArea.style.transform = 'translateY(calc(var(--ref-pos)*0.55))'
                        dropArea.style.backgroundColor = 'hsl(219, 100%, 50%)';
                    } else if (sdrop == "Sumatra") {
                        dropArea.style.opacity = 0;
                        dropArea3.style.opacity = 0;
                        dropArea2.style.transform = 'translateY(calc(var(--ref-pos)*1.55))'
                    } else if (sdrop == "Kalimantan") {
                        dropArea.style.opacity = 0;
                        dropArea2.style.opacity = 0;
                        dropArea3.style.transform = 'translateY(calc(var(--ref-pos)*2.55))'
                        dropArea3.style.backgroundColor = 'hsl(219, 100%, 50%)';
                    }
                    console.log(items);
                    console.log(`Upload Status ${droppedFiles.length} file(s):`);
                    uploadStatus.innerText = `Upload Status ${droppedFiles.length} file(s):`;
                    // uploadStatus.style.transform = 'translateY(0px)';
                    uploadStatus.style.opacity = '1';
                    // uploadStatus.style.lineHeight = '70px';
                    console.log('Dropped at: ' + sdrop);
                    uploadall(items, sdrop);
                }
                lowerdiv.classList.remove('hovered');

            }

            function getRectangleDroppedOn(x, y) {
                for (let i = 0; i < rectangles.length; i++) {
                    const rect = rectangles[i].getBoundingClientRect();
                    if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                        return rectangles[i];
                    }
                }
                return null;
            }
        });

        function uploadall(items, region) {
            // Clear previous images in the container
            imageContainer.innerHTML = '';
            uploadStatus.innerHTML = '';
            startTime = performance.now();

            let files = [];
            let folders = [];
            let folderpaths = [];
            let uploadcount = 0;
            let successcount = 0;
            let failcount = 0;
            let sfail = '';
            let isSending = false;
            const sendQueue = [];

            function sendPostRequest(foldername, newfolder, folders, folderId) {
                return new Promise((resolve, reject) => {
                    const requestData = {
                        folder: foldername,
                        newfolder: newfolder,
                        folders: folders,
                        folderId: folderId
                    };

                    sendQueue.push({ requestData, resolve, reject });

                    if (!isSending) {
                        processQueue();
                    }
                });
            }

            function processQueue() {
                if (sendQueue.length === 0) {
                    isSending = false;
                    return;
                }

                isSending = true;
                const { requestData, resolve, reject } = sendQueue.shift();


                fetch(url, {
                    redirect: "follow",
                    method: 'POST',
                    body: JSON.stringify(requestData),
                    headers: {
                        "Content-Type": "text/plain;charset=utf-8",
                    },
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}`);
                        }
                        return response.text();
                    })
                    .then(responseData => {
                        console.log("server's respond:" + responseData);
                        resolve(responseData);
                        processQueue(); // Process next request
                    })
                    .catch(error => {
                        console.error('Error:', error.message);
                        reject(error);
                        processQueue(); // Process next request
                    });
            }

            function updateDuration() {
                const endTime = performance.now();
                const duration = ((endTime - startTime) / 1000).toFixed(1);
                // uploadStatus.innerText = "\nCreating slide.. <i>" + duration + " sec</i>";
                uploadStatus.innerHTML = "\nCreating slide.. <i>" + duration + " sec</i>";
            }

            async function postfile4(file, folderpath, folderId) {
                return new Promise((resolve, reject) => {
                    let fr = new FileReader();
                    fr.onloadend = () => {
                        let res = fr.result;
                        let spt = res.split("base64,")[1];
                        let obj = {
                            base64: spt,
                            type: file.type,
                            name: file.name,
                            folder: folderpath,
                            folderId: folderId
                        };
                        fetch(url, {
                            redirect: "follow",
                            method: 'POST',
                            body: JSON.stringify(obj),
                            headers: {
                                "Content-Type": "text/plain;charset=utf-8",
                            },

                        })
                            .then(r => r.text())
                            .then(data => {

                                if (data.includes("uploaded")) {
                                    successcount = successcount + 1;
                                    //console.log('uploadcount=' + uploadcount);
                                }
                                else {
                                    failcount = failcount + 1;
                                }

                                let status = data.includes("uploaded") ? "" : '\n' + file.path;
                                sfail += `${status}`;


                                endTime = performance.now();
                                duration = ((endTime - startTime) / 1000).toFixed(1);
                                console.log("Uploading " + successcount + " files: " + duration + " s");

                                endTime = performance.now();
                                duration = ((endTime - startTime) / 1000).toFixed(1);
                                var duration1 = duration;
                                //uploadStatus.innerText = "\nUploading " + successcount + " of " + uploadcount + " <i>" + duration + " sec</i>";
                                uploadStatus.innerHTML = "\nUploading " + successcount + " of " + uploadcount + " <i>" + duration + " sec</i>";
                                console.log("debug uploadcount=" + uploadcount + " successcount=" + successcount);
                                if (uploadcount == successcount) {
                                    console.log("debug last upload");
                                    let intervalID = setInterval(updateDuration, 4700);

                                    //uploadStatus.innerText = "\nUpload successful (" + duration + " sec)" + "\nNow creating slide..";

                                    sendPostRequest('done', true, folderpaths, folderId).then(responseData => {

                                        // To stop the interval, call clearInterval with the interval ID
                                        clearInterval(intervalID);

                                        console.log("response:", responseData);
                                        if (responseData.startsWith("ack done")) {
                                            var splittedData = responseData.split(";");
                                            var folderLink = splittedData[1].trim(); // Second split for folder
                                            var slideLink = splittedData[2].trim(); // Third split for slide
                                            var duration2 = splittedData[3].trim(); // Third split for slide
                                            var duration3 = splittedData[4].trim(); // Third split for slide
                                            var duration4 = splittedData[5].trim(); // Third split for slide

                                            // Further operations with splittedData
                                            uploadStatus.innerText = "\nUpload finished " + " " + duration1 + " sec";
                                            uploadStatus.innerText += "\nSlide created   " + " " + duration2 + " sec";
                                            uploadStatus.innerText += "\nSheet updated   " + " " + duration3 + " sec";
                                            uploadStatus.innerText += "\nReminder sent  " + " " + duration4 + " sec";
                                            uploadStatus.innerHTML += '<br><br><a href="' + folderLink + '" target="_blank" style="color: white;">folder</a>'; // Adding folder hyperlink with target="_blank" and white text color
                                            uploadStatus.innerHTML += '<br><a href="' + slideLink + '" target="_blank" style="color: white;">slide</a>'; // Adding slide hyperlink with target="_blank" and white text color
                                            // Handle the server response as needed
                                        }
                                    })
                                        .catch(error => {
                                            console.error("Error:", error);
                                            // Handle errors if the request fails
                                        });

                                    // folderResponses.push(folderResponse);
                                    // await Promise.all(folderResponses);
                                }

                                //uploadStatus.innerText += `${status}`;
                                // let img = document.createElement("img");
                                // img.style.maxWidth = "300px";
                                // img.style.height = "auto";
                                // img.src = res;
                                // imageContainer.appendChild(img);
                                resolve(data); // Resolve the promise with the response
                            })
                            .catch(error => reject(error)); // Reject the promise if there's an error
                    };
                    fr.readAsDataURL(file);
                });
            }


            async function traverseItems(currentItem, path) {
                if (currentItem.isFile) {
                    // If it's a file, add it to the files array
                    const file = await new Promise(resolve => currentItem.file(resolve));
                    let filePath = path;
                    if (filePath.endsWith('/')) {
                        filePath = filePath.slice(0, -1); // Remove the trailing '/'
                    }
                    files.push({ item: file, name: filePath });
                    //console.log("inFiles:" + file.name, files);
                } else if (currentItem.isDirectory) {
                    // If it's a directory, iterate through its items
                    folders.push({ item: currentItem, name: path + currentItem.name + '/' });
                    folderpaths.push(path + currentItem.name + '/');
                    let directoryReader = currentItem.createReader();
                    let entries = await new Promise(resolve => directoryReader.readEntries(resolve));
                    for (let entry of entries) {
                        await traverseItems(entry, path + currentItem.name + "/");
                    }
                }
            }



            async function handleDroppedItems(items) {
                try {
                    // Array to store promises
                    const promises = [];

                    // Iterate through dropped items
                    for (let i = 0; i < items.length; i++) {
                        let item = items[i].webkitGetAsEntry();
                        if (item) {
                            // Push each promise returned by traverseItems to promises array
                            promises.push(traverseItems(item, ""));
                        }
                    }

                    // Wait for all promises to resolve
                    await Promise.all(promises);

                    startTime = performance.now();

                    // Process files and folders sequentially
                    // console.log("Files:", files);
                    // console.log("Folders:", folders);
                    // console.log("folderpaths:", folderpaths);
                    uploadStatus.innerText = "\nCreating " + folders.length + " folder(s)..";

                    let folderResponses = [];

                    let folderId = '';
                    if (region == "Java") {
                        folderId = folder_java;
                    } else if (region == "Sumatra") {
                        folderId = folder_sumatra;
                    } else if (region == "Kalimantan") {
                        folderId = folder_kalimantan;
                    } else {
                        folderId = '';
                    }
                    console.log("creating " + folders.length + " folder(s)" + " in " + region + " " + folderId);
                    let folderResponse = sendPostRequest('', true, folderpaths, folderId);
                    folderResponses.push(folderResponse);


                    await Promise.all(folderResponses);
                    endTime = performance.now();
                    duration = ((endTime - startTime) / 1000).toFixed(1);
                    console.log("Create folders: " + duration + " s");
                    startTime = performance.now();

                    uploadcount = files.length;
                    console.log("Uploading " + uploadcount + " files..");
                    uploadStatus.innerText = "\nUploading " + uploadcount + " files..";

                    async function limitConcurrency(tasks, concurrencyLimit, asyncTask) {
                        const executing = [];
                        const enqueue = async () => {
                            if (tasks.length > 0 && executing.length < concurrencyLimit) {
                                const task = tasks.shift();
                                const promise = asyncTask(task);
                                executing.push(promise);
                                promise.then(() => executing.splice(executing.indexOf(promise), 1));
                                promise.finally(enqueue);
                            }
                        };

                        await Promise.all(Array.from({ length: concurrencyLimit }, enqueue));
                    }

                    async function handleFilesWithLimit(files) {
                        const fileResponses = [];

                        // Define the asynchronous task to be executed with concurrency limit
                        async function asyncTask(file) {
                            const fileResponse = await postfile4(file.item, file.name, folderId);
                            fileResponses.push(fileResponse);
                        }

                        // Limit concurrency to 32 tasks

                        await limitConcurrency(files, 32, asyncTask);


                        // Await all remaining tasks to complete
                        await Promise.all(fileResponses);
                        //uploadStatus.innerText = "\nTotal upload=" + files.length + "\nFinished=" + uploadcount + '\nFailed:' + failcount + sfail;
                        //console.log("All items processed.");

                    }

                    handleFilesWithLimit(files)
                        .then(() => {
                            console.log("Uploading all files");
                        })
                        .catch(error => console.error("Error processing files:", error));



                } catch (error) {
                    console.error("Error handling dropped items:", error);
                }
            }
            console.log(items);
            handleDroppedItems(items);



        }


    </script>
    <script>
        function getParameterByName(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[\]]/g, '\\$&');
            var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, ' '));
        }

        var siteidValue = getParameterByName('siteid');
        console.log('Value of "siteid" query parameter:', siteidValue);
        if (siteidValue) {
            console.log('Value of "siteid" query parameter:', siteidValue);
            var searchInput = document.getElementById("searchInput");
            searchInput.value = siteidValue.toUpperCase();
            
            searchSite();
        } else {
            console.log('No value found for "siteid" query parameter');
        }
		document.addEventListener("keydown", function (e) {
			if (e.ctrlKey && e.key === 'q') {
				const myNav = document.getElementById("myNav");
				if (myNav.style.width === "100%") {
					closeNav();
				} else if ((myNav.style.width === "0%" || myNav.style.width === "") && resultArray.length > 0) {
					openNav(currentGalleryIndex);
				}
			}
		});		

  // callback invoked by JSONP response from GAS
  function setLastCellUrl(url) {
    if (!url) return;
    try {
      var iframe = document.getElementById('leftBottomFrame');
      iframe.src = url;
      console.log('leftBottomFrame src set to', url);
    } catch (e) {
      console.error('Error setting iframe src', e);
    }
  }


			
	const AREA_SHEETS = {
	  KAL: 'QTD KAL',        // Kalimantan
	  CJ:  'QTD CJ',         // Central Java
	  EJ:  'QTD EJ',         // East Java
	  SS:  'QTD SS',         // South Sumatra
	  NS:  'QTD NS',         // North Sumatra
	  ALL: 'ALL'             // special token meaning "use default/global"
	};
	
	/* small cookie helpers - persistent cookie (10 years) */
	function setCookie(name, value, days = 3650) {
	  const expires = new Date(Date.now() + days * 24*60*60*1000).toUTCString();
	  document.cookie = `${name}=${encodeURIComponent(value)}; expires=${expires}; path=/`;
	}
	function getCookie(name) {
	  const m = document.cookie.match('(?:^|; )' + name + '=([^;]*)');
	  return m ? decodeURIComponent(m[1]) : null;
	}
	function deleteCookie(name) {
	  document.cookie = name + '=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/';
	}
	
	/* Build & inject the JSONP call to GAS.
	   If sheetName is null OR 'ALL' -> request default behavior (no sheet param).
	   If sheetName provided -> add &sheet=...&last3=1 (so server can return last-3-row URL) */
	function injectLastcellJSONP(sheetName) {
	  let gasUrl = url + '?action=lastcell&callback=setLastCellUrl';
	  if (sheetName && sheetName !== 'ALL') {
	    gasUrl += '&sheet=' + encodeURIComponent(sheetName) + '&last3=1';
	  }
	  const s = document.createElement('script');
	  s.src = gasUrl;
	  s.async = true;
	  document.head.appendChild(s);
	}
	
	/* Show a small modal dialog to let user pick area(s). Multiple allowed.
	   If exactly one area chosen and not ALL, we request that sheet's last-3 rows.
	   Otherwise fallback to default (inject without sheet param). */


	function showAreaDialog(onSave) {
	  if (!document.getElementById('qtd-area-modal-styles')) {
	    var s = document.createElement('style');
	    s.id = 'qtd-area-modal-styles';
	    s.textContent =
	      ':root{--brand:hsl(219,100%,50%);}#qtd-area-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:2147483647;background:rgba(0,0,0,0.5);backdrop-filter:blur(3px);}#qtd-area-card{width:360px;max-width:92%;background:#fff;border-radius:12px;padding:18px 18px 14px;font-family:Inter,system-ui,Arial,Helvetica,sans-serif;color:#0b1220;box-shadow:0 8px 20px rgba(10,20,40,0.08);transition:opacity .18s ease,transform .18s ease;transform:translateY(0);}#qtd-area-title{font-weight:700;margin:0 0 12px 0;font-size:15px;}#qtd-area-grid{display:flex;flex-direction:column;gap:8px;margin-bottom:14px;}#qtd-area-grid label{display:flex;align-items:center;gap:10px;padding:10px;border-radius:10px;border:1px solid rgba(11,18,32,0.06);cursor:pointer;transition:box-shadow .14s ease,transform .14s ease;background:#fff;}#qtd-area-grid label:hover{box-shadow:0 6px 18px rgba(11,18,32,0.06);transform:translateY(-2px);}#qtd-area-grid input{width:18px;height:18px;accent-color:var(--brand);}#qtd-area-actions{display:flex;justify-content:flex-end;gap:10px;}#qtd-area-actions button{padding:8px 12px;border-radius:8px;border:0;cursor:pointer;font-weight:600;transition:transform .12s ease,opacity .12s ease;}#qtd-area-cancel{background:transparent;color:#334155;border:1px solid rgba(51,65,85,0.08);}#qtd-area-save{background:var(--brand);color:#fff;box-shadow:0 6px 14px rgba(33,100,255,0.10);}#qtd-area-note{font-size:12px;color:#556176;margin-top:10px;}@media (prefers-reduced-motion:reduce){#qtd-area-card,#qtd-area-grid label,#qtd-area-actions button{transition:none;}}';
	    document.head.appendChild(s);
	  }
	
	  var overlay = document.createElement('div');
	  overlay.id = 'qtd-area-overlay';
	  overlay.setAttribute('role', 'dialog');
	  overlay.setAttribute('aria-modal', 'true');
	
	  var card = document.createElement('div');
	  card.id = 'qtd-area-card';
	
	  var title = document.createElement('h3');
	  title.id = 'qtd-area-title';
	  title.textContent = 'Select Working Area';
	
	  var grid = document.createElement('div');
	  grid.id = 'qtd-area-grid';
	
	  var areas = [
	    { code: 'KAL', name: 'Kalimantan' },
	    { code: 'CJ', name: 'Central Java' },
	    { code: 'EJ', name: 'East Java' },
	    { code: 'SS', name: 'South Sumatra' },
	    { code: 'NS', name: 'North Sumatra' },
	    { code: 'ALL', name: 'All area' }
	  ];
	
	  for (var i = 0; i < areas.length; i++) {
	    var a = areas[i];
	    var lbl = document.createElement('label');
	    lbl.setAttribute('data-area', a.code);
	    var cb = document.createElement('input');
	    cb.type = 'checkbox';
	    cb.setAttribute('data-area', a.code);
	    cb.setAttribute('aria-label', a.name);
	    var span = document.createElement('span');
	    span.textContent = a.name;
	    lbl.appendChild(cb);
	    lbl.appendChild(span);
	    grid.appendChild(lbl);
	  }
	
	  var actions = document.createElement('div');
	  actions.id = 'qtd-area-actions';
	  var cancel = document.createElement('button');
	  cancel.id = 'qtd-area-cancel';
	  cancel.type = 'button';
	  cancel.textContent = 'Cancel (use default)';
	  var save = document.createElement('button');
	  save.id = 'qtd-area-save';
	  save.type = 'button';
	  save.textContent = 'Save & Continue';
	
	  actions.appendChild(cancel);
	  actions.appendChild(save);
	
	  var note = document.createElement('div');
	  note.id = 'qtd-area-note';
	  note.innerHTML = 'You can reselect later by clearing the cookie</code>';
	
	  card.appendChild(title);
	  card.appendChild(grid);
	  card.appendChild(actions);
	  card.appendChild(note);
	  overlay.appendChild(card);
	  document.body.appendChild(overlay);
	
	  var prevOverflow = document.body.style.overflow;
	  document.body.style.overflow = 'hidden';
	
	  var firstCb = grid.querySelector('input[type=checkbox]');
	  if (firstCb) { firstCb.focus(); }
	
	  function collectSelected() {
	    var checks = grid.querySelectorAll('input[type=checkbox]');
	    var sel = [];
	    for (var j = 0; j < checks.length; j++) {
	      if (checks[j].checked) sel.push(checks[j].getAttribute('data-area'));
	    }
	    if (sel.indexOf('ALL') !== -1 || sel.length === 0) return ['ALL'];
	    return sel;
	  }
	
	  function closeAndCleanup(resultArray) {
	    try { onSave(resultArray); } catch (e) { /* ignore */ }
	    if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
	    document.body.style.overflow = prevOverflow || '';
	    document.removeEventListener('keydown', keyHandler, true);
	    // small delay so any immediate handlers (inject JSONP / setCookie) run, then reload
	    //setTimeout(function () { try { location.reload(); } catch (e) { /* ignore */ } }, 220);
	  }
	
	  save.addEventListener('click', function () { closeAndCleanup(collectSelected()); });
	  cancel.addEventListener('click', function () { closeAndCleanup(['ALL']); });
	
	  overlay.addEventListener('click', function (ev) {
	    if (ev.target === overlay) closeAndCleanup(['ALL']);
	  });
	
	  grid.addEventListener('change', function (ev) {
	    var target = ev.target;
	    if (!target || target.type !== 'checkbox') return;
	    if (target.getAttribute('data-area') === 'ALL' && target.checked) {
	      var all = grid.querySelectorAll('input[type=checkbox]');
	      for (var k = 0; k < all.length; k++) {
	        if (all[k].getAttribute('data-area') !== 'ALL') all[k].checked = false;
	      }
	    } else if (target.checked) {
	      var allbox = grid.querySelector('input[data-area=\"ALL\"]');
	      if (allbox) allbox.checked = false;
	    }
	  });
	
	  function keyHandler(e) {
	    if (e.key === 'Escape' || e.keyCode === 27) {
	      e.preventDefault();
	      closeAndCleanup(['ALL']);
	    }
	  }
	  document.addEventListener('keydown', keyHandler, true);
	}



		
	(function initAreaChoice() {
	  var cookie = getCookie('qtd_area');
	  if (cookie) {
	    var areas = cookie.split(',').filter(Boolean);
	    var first = areas[0];
	    if (first && first !== 'ALL') {
	      var sheetName = AREA_SHEETS[first] || first;
	      injectLastcellJSONP(sheetName);
	    } else {
	      injectLastcellJSONP(null);
	    }
	    return;
	  }
	
	  // no cookie: ask user
	  showAreaDialog(function(selectedAreas) {
	    // persist
	    setCookie('qtd_area', selectedAreas.join(','));
	    var sel = (selectedAreas || []).filter(Boolean);
	    var firstSel = sel[0];
	    if (firstSel && firstSel !== 'ALL') {
	      var sheet = AREA_SHEETS[firstSel] || firstSel;
	      injectLastcellJSONP(sheet);
	    } else {
	      injectLastcellJSONP(null);
	    }
	  });
	})();	


		
    </script>
</body>

</html>
